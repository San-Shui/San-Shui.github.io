<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript作用域、上下文、执行期上下文、作用域链、闭包]]></title>
    <url>%2F2017%2F11%2F07%2FJavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E6%89%A7%E8%A1%8C%E6%9C%9F%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E3%80%81%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;作用域、上下文、执行期上下文、作用域链、闭包是JavaScript中关键概念之一，是JavaScript难点之一，在应聘面试时必定会问到的问题，作为前端工程师必须理解和掌握。相信大家已经阅读了很多关于这方面的文章，但是看完之后似懂非懂。在我阅读了《JavaScript高级程序设计》、《高性能的JavaScript》这两本书后，我才完全理解这些概念。 ###一、作用域(Scope) &emsp;&emsp;作用域概念是理解JavaScript的关键所在，不仅仅从性能角度，还包括从功能角度。作用域就是变量和函数的可访问范围，控制着变量和函数的可见性与生命周期，换句话说，作用域决定了代码区块中变量和其他资源的可见性。在JavaScript中变量的作用域有全局作用域和局部作用域。JavaScript采用词法作用域(lexical scoping)，也就是静态作用域。 静态作用域与动态作用域 词法作用域：词法作用域是指在词法分析阶段就确定了，不会改变。变量的作用域是在定义时决定而不是执行时决定，也就是说词法作用域取决于源码，通过静态分析就能确定，因此词法作用域也叫做静态作用域。 动态作用域：动态作用域是在运行时根据程序的流程信息来动态确定的，而不是在写代码时进行静态确定的。 动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们在何处调用。 JavaScript的词法作用域 &emsp;&emsp;如果一个文档流中包含多个script代码段（用script标签分隔的js代码或引入的js文件），它们的运行顺序是： 读入第一个代码段（js执行引擎并非一行一行地分析程序，而是一段一段地分析执行的） 做词法分析，有错则报语法错误（比如括号不匹配等），并跳转到步骤5 对var变量和function定义做“预解析“（永远不会报错的，因为只解析正确的声明） 执行代码段，有错则报错（比如变量未定义） 如果还有下一个代码段，则读入下一个代码段，重复步骤2 完成 下面看一个例子就能明白JavaScript的词法作用域：12345678910var value = 1;function foo() &#123; console.log(value);&#125;function bar() &#123; var value = 2; foo();&#125;bar();// 结果是 ??? 假设JavaScript采用静态作用域，让我们分析下执行过程： &emsp;&emsp;执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。 假设JavaScript采用动态作用域，让我们分析下执行过程： &emsp;&emsp;执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。 前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1。 全局作用域、局部作用域和块级作用域 &emsp;&emsp;在ECMAScript 5（包括ECMAScript 5）之前的版本中，作用域只有全局作用域和局部作用域，不存在块级作用域；ECMAScript 6引入了let和const关键字，利用let和const可以形成块级作用域。 1、全局作用域 &emsp;&emsp;在代码中任何地方都能访问到的对象拥有全局作用域。全局作用域的变量是全局对象的属性，不论在什么函数中都可以直接访问，而不需要通过全局对象，但加上全局对象，可以提供搜索效率。 a.没有用var声明的变量（除去函数的参数）都具有全局作用域，成为全局变量，所以声明局部变量必须要用var。 b.window的所有属性都具有全局作用域 c.最外层函数体外声明的变量也具有全局作用域 2、局部作用域 局部变量的优先级高于全局变量。 a.函数体内用var声明的变量具有局部作用域，成为局部变量 b.函数的参数也具有局部作用域12345678910111213var a=3; // 全局变量 function fn(b)&#123; // 局部变量 c=2; // 全局变量 var d=5; // 局部变量 function subFn()&#123; var e=d; // 父函数的局部变量对子函数可见 for(var i=0;i&lt;3;i++)&#123; console.write(i); &#125; alert(i);// 3, 在for循环内声明，循环外function内仍然可见，没有块作用域 &#125; &#125; alert(c); // 在function内声明但不带var修饰，仍然是全局变量 3、块级作用域 使用let和const关键字声明的变量，会在形成块级作用域。123456789101112if (true) &#123; // 'if' 条件语句块不会创建一个新的作用域 // name 在全局作用域中，因为通过 'var' 关键字定义 var name = 'Hammad'; // likes 在局部（本地）作用域中，因为通过 'let' 关键字定义 let likes = 'Coding'; // skills 在局部（本地）作用域中，因为通过 'const' 关键字定义 const skills = 'JavaScript and PHP';&#125;console.log(name); // logs 'Hammad'console.log(likes); // Uncaught ReferenceError: likes is not definedconsole.log(skills); // Uncaught ReferenceError: skills is not defined ###二、上下文(context) &emsp;&emsp;许多开发人员经常混淆作用域(scope)和上下文(context)，很多误解为它们是相同的概念。但事实并非如此。作用域(scope)我们上面已经讨论过了，而上下文(context)是用来指定代码某些特定部分中this的值。作用域(scope) 是指变量的可访问性，上下文(context)是指this在同一作用域内的值。我们也可以使用call()、apply()、bind()、箭头函数等改变上下文。在浏览器中在全局作用域(scope)中上下文中始终是Window对象。在Node.js中在全局作用域(scope)中上下文中始终是Global 对象。12345678var name = "windowsName";function a() &#123; var name = "Cherry"; console.log(this.name); // windowsName console.log("inner:" + this);// inner: Window&#125;a();console.log("outer:" + this) // outer: Window &emsp;&emsp;上下文始终坚持一个原理：this 永远指向最后调用它的那个对象，上例中调用a函数的是window，所以a函数中的this指向window对象。关于this以及改变this的指向，可以参考this、apply、call、bind ###三、作用域链(Scope Chain) &emsp;&emsp;JavaScript 中每个函数都都表示为一个函数对象（函数实例），函数对象有一个仅供 JavaScript 引擎使用的[[scope]] 属性。通过语法分析和预解析，将[[scope]] 属性指向函数定义时作用域中的所有对象集合。这个集合被称为函数的作用域链（scope chain），包含函数定义时作用域中所有可访问的数据。1234function add(num1, num2) &#123; var sum = num1 + num2; return sum;&#125; &emsp;&emsp;当定义 add 函数后，其作用域链就创建了。函数所在的全局作用域的全局对象被放置到 add 函数作用域链（[[scope]] 属性）中。我们可以从下图中看到作用域链的第一个对象保存的是全局对象，全局对象中保存了诸如 this , window , document 以及全局对象中的 add 函数，也就是他自己。这也就是我们可以在全局作用域下的函数中访问 window(this)，访问全局变量，访问函数自身的原因。 ###四、执行期上下文(Execution Context)&emsp;&emsp;执行具体的某个函数时，JS引擎在执行每个函数实例时，都会创建一个执行期上下文（Execution Context）和激活对象（active Object）（它们属于宿主对象，与函数实例执行的生命周期保持一致，也就是函数执行完成，这些对象也就被销毁了，闭包例外。） 假设我们运行以下代码：1var total = add(5, 10); &emsp;&emsp;执行该函数创建一个内部对象，称为 Execution Context（执行期上下文）。执行期上下文定义了一个函数正在执行时的作用域环境。特别注意，执行期上下文和我们平常说的上下文不同，执行期上下文指的是作用域。平常说的上下文是this的取值指向。执行期上下文和函数创建时的作用域链对象 [[scope]] 区分，这是两个不同的作用域链对象。分开的原因很简单，函数定义时的作用域链对象 [[scope]] 是固定的，而 执行期上下文 会根据不同的运行时环境变化。而且该函数每执行一次，都会创建单独的 执行期上下文，因此对同一函数调用多次，会导致创建多个执行期上下文。一旦函数执行完成，执行期上下文将被销毁。 &emsp;&emsp;执行期上下文对象有自己的作用域链，当创建执期行上下文时，其作用域链将使用执行函数[[scope]]属性所包含的对象（即，函数定义时的作用域链对象）进行初始化。这些值按照它们在函数中出现的顺序复制到执行期上下文作用域链中。 激活对象(Activation Object) &emsp;&emsp;随后，在执行其上下文中创建一个名为 Activation Object（激活对象）的新对象。 这个激活对象保存了函数中的所有形参，实参，局部变量，this 指针等函数执行时函数内部的数据情况。然后将这个激活对象推送到执行其上下文作用域链的顶部。 &emsp;&emsp;激活对象是一个可变对象，里面的数据随着函数执行时的数据的变化而变化，当函数执行结束之后，执行期上下文将被销毁。也就会销毁Execution Context的作用域链，激活对象也同样被销毁。但如果存在闭包，激活对象就会以另外一种方式存在，这也是闭包产生的真正原因，具体的我们稍后讨论。下图显示了执行上下文及其作用域链： &emsp;&emsp;从左往右看，第一部分是函数执行时创建的执行期上下文，它有自己的作用域链，第二部分是作用域链中的对象，索引为1的对象是从[[scope]]作用域链中复制过来的，索引为0的对象是在函数执行时创建的激活对象，第三部分是作用域链中的对象的内容Activation Object(激活对象)和Global Object(全局对象)。 &emsp;&emsp;函数在执行时，每遇到一个变量，都会去执行期上下文的作用域链的顶部，执行函数的激活对象开始向下搜索，如果在第一个作用域链（即，Activation Object 激活对象）中找到了，那么就返回这个变量。如果没有找到，那么继续向下查找，直到找到为止。如果在整个执行期上下文中都没有找到这个变量，在这种情况下，该变量被认为是未定义的。这也就是为什么函数可以访问全局变量，当局部变量和全局变量同名时，会使用局部变量而不使用全局变量，以及 JavaScript 中各种看似怪异的、有趣的作用域问题的答案。 ###五、闭包（Closure）&emsp;&emsp;闭包（Closure）是 JavaScript 最强大的特性之一，它允许函数访问局部作用域之外的数据。闭包在日常编码工作中非常常见。但是，它会对性能造成影响。了解闭包我们使用以下示例代码：123456function assignEvents()&#123; var id = "xdi9592"; document.getElementById("save-btn").onclick = function(event) &#123; saveDocument(id); &#125;;&#125; &emsp;&emsp;assignEvents 函数为DOM元素分配一个事件处理程序。这个处理函数就是一个闭包。为了使该闭包访问id变量，必须创建一个特定的作用域链。 我们一起来从作用域的角度分析一下闭包的形成过程： &emsp;&emsp;assignEvents 函数创建并且词法解析后，函数对象assignEvents的[[scope]]属性被初始化，作用域链形成，作用域链中包含了全局对象的所有属性和方法（注意，此时因为 assignEvents 函数还未被执行，所以闭包函数并没有被解析）。 &emsp;&emsp;assignEvents 开始执行时，创建 Execution Context（执行期上下文），在执行期上下文的作用域链中创建 Activation Object(激活对象)，并将 Activation Object(激活对象) 推送到作用域链顶部，在其中保存了函数执行时所有可访问函数内部的数据。激活对象包含 id 变量。 &emsp;&emsp;当执行到闭包时，JavaScript 引擎发现了闭包函数的存在，按照通常的手法，将闭包函数解析，为闭包函数对象创建 [[scope]] 属性，初始化作用域链。特别注意的是，这个时候，闭包函数对象的作用域链中有两个对象，一个是 assignEvents 函数执行时的 Activation Object(激活对象) ，还有一个是全局对象，如下图： &emsp;&emsp;我们看到图中闭包函数对象的作用域链和 assignEvents 函数的执行期上下文的作用域链是相同的。为什么相同呢？我们来分析一下，闭包函数是在 assignEvents 函数执行的过程中被定义并且解析的，而函数执行时的作用域是 Activation Object(激活对象) ，闭包函数被解析的时候它的作用域正是 assignEvents 作用域链中的第一个作用域对象 Activation Object(激活对象) ，当然，由于作用域链的关系，全局对象作用域也被引入到闭包函数的作用域链中。 &emsp;&emsp;在词法分析的时候闭包函数的 [[scope]] 属性 就已经在作用域链中保存了对 assignEvents 函数的 Activation Object(激活对象) 的引用，所以当 assignEvents 函数执行完毕之后，闭包函数虽然还没有开始执行，但依然可以访问 assignEvents 的局部数据，并不是因为闭包函数要访问 assignEvents 的局部变量id，所以当 assignEvents 函数执行完毕之后依然保持了对局部变量id的引用。而是不管是否存在变量引用，都会保存对 assignEvents 的 Activation Object(激活对象)作用域对象的引用。因为在词法分析时，闭包函数没有执行，函数内部根本就不知道是否要对 assignEvents 的局部变量进行访问和操作，所以只能先把 assignEvents 的 Activation Object(激活对象) 作用域对象保存起来，当闭包函数执行时，如果需要访问 assignEvents 的局部变量，那么再去作用域链中查找。 &emsp;&emsp;也正是因为这种引用，造成了一个副作用。通常，当执行期上下文被销毁时，函数的激活对象也就被销毁了。当有闭包引用时，激活对象就不会被销毁，因为他仍然被引用。这意味着闭包比非隔离的函数需要更多的内存。 &emsp;&emsp;闭包函数执行时创建了自己的 Execution Context（执行期上下文），其作用域链使用了 [[scope]] 属性，其引用了 assignEvents 函数的 Activation Object(激活对象) 和 全局对象。然后为闭包本身创建一个新的 Activation Object(激活对象)。 所以在闭包函数的执行期上下文的作用域链中保存了自己的 Activation Object(激活对象)，外层函数 assignEvents Execution Context（执行期上下文）的 Activation Object(激活对象)，以及 Global Object(全局对象)，如图：]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VScode搭建TypeScript开发环境]]></title>
    <url>%2F2017%2F10%2F17%2FVScode%E6%90%AD%E5%BB%BATypeScript%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上。TypeScript 编译工具可以运行在任何服务器和任何系统上，TypeScript 是开源的。为什么选择 TypeScript以及TypeScript优缺点阅读TypeScript入门教程。利用VScode搭建TypeScript开发环境前提是已经安装node.js和VScode。 1、安装TypeScript使用npm工具安装全局TypeScript： npm install -g typescript 2、创建helloTypeScript创建helloTypeScript目录，在命令行cmd下进入helloTypeScript目录 cd helloTypeScript 输入：npm init，创建package.json，package.json文件如下： 12345678910111213141516171819202122232425&#123; "name": "hellotypescript", "version": "1.0.0", "description": "hello typescript", "main": "index.html", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "start": "tsc &amp;&amp; concurrently \"npm run tsc:w\" \"npm run lite\"", "lite": "lite-server", "tsc": "tsc", "tsc:w": "tsc -w" &#125;, "keywords": [ "typescript" ], "author": "sanshui", "license": "ISC", "dependencies": &#123; &#125;, "devDependencies": &#123; "lite-server": "^2.2.0", "concurrently": "^2.0.0" &#125;&#125; concurrently—同时执行命令用 lite-server—轻量级的Node开发服务器 3、安装依赖包、编写示例代码使用npm i 或者 cnpm i 或者yarn 安装依赖包 npm i 编写HelloTypeScript.ts代码： 1234567891011121314class HelloTypeScript &#123; helloString: string; constructor(message: string) &#123; this.helloString = message; &#125; hello() &#123; return this.helloString; &#125;&#125;let myName: string = 'SanShui'let myAge: number = 23let sentence: string = `Hello, my name is $&#123;myName&#125;. I'll be $&#123;myAge + 1&#125; years old next month`let helloTypeScript = new HelloTypeScript(sentence);document.body.innerHTML = helloTypeScript.hello(); index.html：12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;HelloTypeScript&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src="dist/tsc.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4、创建 tsconfig.json&emsp;&emsp;当前TypeScript代码并不能直接执行，需编译为JavaScript代码。而借助VS Code，我们就不用在命令行输入编译命令了。为此，在根目录添加一个tsconfig.json文件。该文件是TypeScript编译器配置文件。 12345678910111213141516&#123; "compilerOptions": &#123; "module": "amd", "noImplicitAny": true, "removeComments": true, "preserveConstEnums": true, "outFile": "dist/tsc.js", "sourceMap": true &#125;, "include": [ "src/*" ], "exclude": [ "node_modules" ]&#125; tsconfig.json详细配置请查看：tsconfig.json配置 5、编译运行 npm run start 编译后目录结构如图： 运行结果如图： 修改TypeScript程序，服务器会自动编译并刷新浏览器。 参考链接： http://www.cnblogs.com/xuanhun/p/6027624.html http://www.cnblogs.com/sunjie9606/p/5945540.html]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器HTTP缓存机制]]></title>
    <url>%2F2017%2F10%2F10%2F%E6%B5%8F%E8%A7%88%E5%99%A8HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[浏览器打开页面时，需要向服务器发送请求，请求静态文件（图片，css，js等），这些静态文件通常不会经常修改，客户端可以将这些不经常修改的静态文件存储起来。当客户端再次请求时，可以直接从本地缓存中读取，这样减少了http请求和服务器负担，加快客户端加载网页速度，提高用户体验，那么这个就是客户端缓存的意义了。 Http 缓存机制作为 web 性能优化的重要手段，很多同学仅仅只是知道浏览器会对请求的静态文件进行缓存，但是为什么被缓存，缓存是怎样生效的，却并不是很清楚。我们首先了解http的传输原理，然后讲解http缓存机制。 1、HTTP的传输原理 HTTP想要发送一条报文的时候，需要经过以下两个步骤： TCP三次握手建立起连接管道，HTTP报文会以流的形式通过该管道按顺序传输； TCP会将这些数据分别切割成数据块，并且封装在IP分组中，通过IP去传输； 使用TCP作为传输层： 传输可靠 有序 一个HTTP请求过程如下图所示： a. 浏览器在发起请求时首先会做什么？答，查找本地缓存 Expires：本地缓存目录中，文件过期的时间（由服务器指定具体的时间） Cache-control：本地缓存目录中，文件过期的时间（由服务器指定过期的间隔时间，由于浏览器根据间隔生成具体的时间） Last-Modified：服务器上文件的最后修改时间 Etag：文件标识 b. 浏览器查找完缓存之后接下来要做的是什么呢？答，DNS query 首先客户机将域名查询请求发送到本地DNS服务器，本地DNS服务器先在之前的记录（缓存）中查找，如果有缓存，则直接利用缓存进行解析，如果没有缓存，则进入本地的缓存的寻找。如果本地服务器不能在本地找到缓存，则将请求发送到根域名DNS服务器。 DNS服务器在拿到我们的域名后，会将它解析成IP地址返回给浏览器，这样浏览器就能直接定位到要请求的服务器的地址了。 c. 找到服务器地址之后肯定就是向服务器发送请求，建立连接，这个不用问了。 这样根据IP和端口，浏览器就开始跟服务器建立TCP连接啦。看到TCP连接，我们就想到了三次握手。 TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认； 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。 完成了三次握手，客户端和服务器端就可以开始传送数据。 d. 浏览器在接收到服务器返回的数据后会怎么做呢？答，解析数据，生成渲染树 渲染展现页面是肯定的啦，关键是如何渲染。我们先来看一下浏览器的简单处理步骤： （1）解析HTML/SVG/XHTML，build DOM树。 （2）解析CSS，build CSSOM树。 （3）build render树。render树并不等同于DOM树，因为一些像Header或display:none的东西就没必要放在render树中了。 （4）reflow。计算每个Element在设备中显示的具体位置。 （5）paint。最后通过调用操作系统Native GUI的API绘制。 2、http报文中与缓存相关的首部字段 我们先来看看RFC2616规定的47种http报文首部字段中与缓存相关的字段，事先了解一下能让咱在心里有个底： 通用首部字段（就是请求报文和响应报文都能用上的字段） 请求首部字段 响应首部字段 实体首部字段 2、缓存规则解析 HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类(强制缓存，对比缓存) 在详细介绍这两种规则之前，先通过时序图的方式，让大家对这两种规则有个简单了解。 已存在缓存数据时，仅基于强制缓存(Cache-control/Expires)，请求数据的流程如下： 已存在缓存数据时，仅基于对比缓存(Etag/Last-Modified)，请求数据的流程如下： 我们可以看到两类缓存规则的不同，强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互。 两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。 3、缓存优先级 Cache-control优先级高于Expires，Etag优先级高于Last-Modified 4、用户行为与缓存 a. 浏览器url回车、页面链接跳转、新开窗口、前进、后退 浏览器发现缓存中有这个文件，就不发送任何请求了，直接去缓存中获取展现。（最快） b. 按下F5刷新 F5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上If-Modify-since。 然后服务器发现：诶，这个文件我在这个时间后还没修改过，不需要给你任何信息了，返回304就行了。于是浏览器获取到304后就去缓存中欢欢喜喜获取资源了。 c. 按下Ctrl+F5 这个可是要命了，告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作。 5、参考链接 网上已经有很多关于Cache-control、Expires、Etag、Last-Modified的经典讲解和实例演示，此处我就不再一一描述，大家参考以下链接： 浅谈浏览器http的缓存机制 彻底弄懂HTTP缓存机制及原理 浏览器的日常生活 你需要知道的HTTP常识 简析TCP的三次握手与四次分手 浏览器 HTTP 协议缓存机制详解 HTTP缓存机制详解]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>缓存机制</tag>
        <tag>http缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sass]]></title>
    <url>%2F2017%2F09%2F20%2Fsass%2F</url>
    <content type="text"><![CDATA[Sass 是对 CSS 的扩展，让 CSS 语言更强大、优雅。 它允许你使用变量、嵌套规则、 mixins、导入等众多功能， 并且完全兼容 CSS 语法。 Sass 有助于保持大型样式表结构良好， 同时也让你能够快速开始小型项目， Sass 有两种语法。 第一种被称为 SCSS (Sassy CSS)，是一个 CSS3 语法的扩充版本，这份参考资料使用的就是此语法。第二种比较老的语法成为缩排语法（或者就称为 “Sass”）， 提供了一种更简洁的 CSS 书写方式。 它不使用花括号，而是通过缩排的方式来表达选择符的嵌套层级，而且也不使用分号，而是用换行符来分隔属性。github地址：https://github.com/San-Shui/sass clone远程仓库到本地： git clone https://github.com/San-Shui/sass.git 进入gulp目录 cd sass 安装依赖 yarn install 或者 npm install 运行项目 gulp 运行之后会生成一个dist目录，dist目录下的文件是通过配置gulp自动生成。 修改src目录下的任何文件都会自动刷新网页 Sass基础—Sass语法：http://www.w3cplus.com/sassguide/syntax.html Sass基础—颜色函数: http://www.w3cplus.com/preprocessor/sass-color-function.html Sass基础—Sass函数:http://www.w3cplus.com/preprocessor/sass-other-function.html &lt;div&gt; 作者：qq_27626333 发表于2017/9/20 22:23:17 [原文链接](http://blog.csdn.net/qq_27626333/article/details/78046323) &lt;/div&gt; &lt;div&gt; 阅读：111 评论：0 [查看评论](http://blog.csdn.net/qq_27626333/article/details/78046323#comments) &lt;/div&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp前端自动化构建工具：常用插件介绍及使用]]></title>
    <url>%2F2017%2F09%2F16%2Fgulp%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%EF%BC%9A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Gulp是基于Node.js的一个构建工具（自动任务运行器），开发者可以使用它构建自动化工作流程（前端集成开发环境）。一些常见、重复的任务，例如：网页自动刷新、CSS预处理、代码检测、压缩图片、等等…… 只需用简单的命令就能全部完成。使用它，可以简化工作，让你把重点放在功能开发上；同时减少人为失误，提高开发效率和项目质量，让专注更为专注。如果你之前接触过Grunt，那上手Gulp就会觉得非常容易理解。 github地址：https://github.com/San-Shui/gulp gulp插件：https://gulpjs.com/plugins/ 本项目使用gulp-webserver创建一个静态服务器，gulp-livereload实现网页自动刷新；同时介绍常用的插件以及插件的使用。 本地安装 要安装最新版本或特定版本，请运行以下命令之一： npm install –save-dev gulp 全局安装 以下的 NPM 安装方式，将使 gulp 在全局环境下可用： npm install –global gulp clone远程仓库到本地： git clone https://github.com/San-Shui/gulp.git 进入gulp目录 cd gulp 安装依赖 yarn install 或者 npm install 运行项目 gulp gulp配置文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229var gulp = require('gulp')// 网页自动刷新（服务器控制客户端同步刷新）var livereload = require('gulp-livereload')// 本地服务器var webserver = require('gulp-webserver')// less文件编译成cssvar less = require('gulp-less') // 压缩css文件var cssmin = require('gulp-clean-css')// 生成sourcemap文件var sourcemaps = require('gulp-sourcemaps')// 当发生异常时提示错误var notify = require('gulp-notify')var plumber = require('gulp-plumber')// 压缩html，可以压缩页面javascript、css，去除页面空格、注释，删除多余属性等操作var htmlmin = require('gulp-htmlmin')// 只操作有过修改的文件var changed = require('gulp-changed')// 压缩图片文件（包括PNG、JPEG、GIF和SVG图片）var imagemin = require('gulp-imagemin')// 深度压缩图片var pngquant = require('imagemin-pngquant')// 只压缩修改的图片，没有修改的图片直接从缓存文件读取（C:\Users\Administrator\AppData\Local\Temp\gulp-cache）。var cache = require('gulp-cache')// 给css文件里引用url加版本号var cssver = require('gulp-make-css-url-version')// 压缩javascript文件，减小文件大小var uglify = require('gulp-uglify')// 文件重命名var rename = require('gulp-rename') // 合并javascript文件，减少网络请求var concat = require('gulp-concat')// 文件清理var clean = require('gulp-clean') /** * 使用gulp-less文件编译成css */gulp.task('lessTask', function() &#123; gulp.src('src/less/*.less') .pipe(plumber(&#123;errorHandler: notify.onError('Error: &lt;%= error.message %&gt;')&#125;)) // 错误提示 .pipe(sourcemaps.init(&#123;loadMaps: true&#125;)) .pipe(rename(&#123; suffix: '.min' &#125;)) // 重命名 .pipe(less()) // 将less文件编译成css .pipe(cssmin()) // 压缩css .pipe(sourcemaps.write('./')) .pipe(gulp.dest('dist/css')) // 将会在dist/css下生成index.css&#125;)/** * watch监测less文件的改变 */gulp.task('lessWatch', function () &#123; gulp.watch('src/**/*.less', ['lessTask']); // 当src文件或者子文件下的某个less文件发生改变时，调用lessTask任务&#125;);/** * 使用gulp-htmlmin压缩html */gulp.task('htmlminTask', function () &#123; var options = &#123; removeComments: true, // 清除HTML注释 collapseWhitespace: true, // 压缩HTML collapseBooleanAttributes: true, // 省略布尔属性的值 &lt;input checked="true"/&gt; ==&gt; &lt;input /&gt; removeEmptyAttributes: true, // 删除所有空格作属性值 &lt;input id="" /&gt; ==&gt; &lt;input /&gt; removeScriptTypeAttributes: true, // 删除&lt;script&gt;的type="text/javascript" removeStyleLinkTypeAttributes: true, // 删除&lt;style&gt;和&lt;link&gt;的type="text/css" minifyJS: true, // 压缩页面JS minifyCSS: true // 压缩页面CSS &#125;; var stream = gulp.src('src/*.html') .pipe(plumber(&#123;errorHandler: notify.onError('Error: &lt;%= error.message %&gt;')&#125;)) // 错误提示 .pipe(changed('dist')) .pipe(htmlmin(options)) .pipe(gulp.dest('dist')) return stream&#125;)/** * 使用gulp-imagemin压缩图片 */gulp.task('imageminTask', function () &#123; var option = &#123; optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级） progressive: false, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: false //类型：Boolean 默认：false 多次优化svg直到完全优化 &#125; gulp.src('src/img/*.&#123;png,jpg,gif,ico&#125;') .pipe(plumber(&#123;errorHandler: notify.onError('Error: &lt;%= error.message %&gt;')&#125;)) // 错误提示 .pipe(imagemin(option)) .pipe(gulp.dest('dist/img'))&#125;)/** * 使用imagemin-pngquant深度压缩图片 */gulp.task('pngquantTask', function () &#123; gulp.src('src/img/*.&#123;png,jpg,gif,ico&#125;') .pipe(plumber(&#123;errorHandler: notify.onError('Error: &lt;%= error.message %&gt;')&#125;)) // 错误提示 .pipe(changed('dist/img')) .pipe(imagemin(&#123; progressive: true,// 无损压缩JPG图片 svgoPlugins: [&#123;removeViewBox: false&#125;],//不要移除svg的viewbox属性 use: [pngquant()] // 使用pngquant深度压缩png图片的imagemin插件 &#125;)) .pipe(gulp.dest('dist/img'));&#125;)/** * 使用gulp-cache只压缩修改的图片 */gulp.task('cacheTask', function () &#123; gulp.src('src/img/*.&#123;png,jpg,gif,ico&#125;') .pipe(plumber(&#123;errorHandler: notify.onError('Error: &lt;%= error.message %&gt;')&#125;)) // 错误提示 .pipe(changed('dist/img')) .pipe(cache(imagemin(&#123; progressive: true, svgoPlugins: [&#123;removeViewBox: false&#125;], use: [pngquant()] &#125;))) .pipe(gulp.dest('dist/img'));&#125;)/** * 使用gulp-clean-css压缩css文件 */gulp.task('cssminTask', function() &#123; var option = &#123; advanced: true,//类型：Boolean 默认：true [是否开启高级优化（合并选择器等）] compatibility: 'ie7',//保留ie7及以下兼容写法 类型：String 默认：''or'*' [启用兼容模式； 'ie7'：IE7兼容模式，'ie8'：IE8兼容模式，'*'：IE9+兼容模式] keepBreaks: false,//类型：Boolean 默认：false [是否保留换行] keepSpecialComments: '*'//保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀 &#125; gulp.src('src/css/*.css') .pipe(plumber(&#123;errorHandler: notify.onError('Error: &lt;%= error.message %&gt;')&#125;)) // 错误提示 .pipe(cssmin(option)) // 压缩css .pipe(gulp.dest('dist/css')) // 将会在dist/css下生成index.css&#125;)/** * 使用gulp-make-css-url-version给css文件里引用url加版本号 */gulp.task('cssverTask', function () &#123; gulp.src('src/css/*.css') .pipe(plumber(&#123;errorHandler: notify.onError('Error: &lt;%= error.message %&gt;')&#125;)) // 错误提示 .pipe(sourcemaps.init()) // 执行sourcemaps .pipe(rename(&#123; suffix: '.min' &#125;)) // 重命名 .pipe(cssver()) //给css文件里引用文件加版本号（文件MD5） .pipe(cssmin()) .pipe(sourcemaps.write('./')) // 地图输出路径（存放位置） .pipe(gulp.dest('dist/css'));&#125;)/** * 使用gulp-uglify压缩javascript文件，减小文件大小。 */gulp.task('uglifyTask', function () &#123; gulp.src(['src/js/*.js', '!src/js/**/scrollspy.js']) .pipe(plumber(&#123;errorHandler: notify.onError('Error: &lt;%= error.message %&gt;')&#125;)) // 错误提示 .pipe(changed('dist/js')) // 对应匹配的文件 .pipe(sourcemaps.init()) // 执行sourcemaps .pipe(rename(&#123; suffix: '.min' &#125;)) // 重命名 .pipe(uglify()) // 使用uglify进行压缩，并保留部分注释 .pipe(sourcemaps.write('./')) // 地图输出路径（存放位置） .pipe(gulp.dest('dist/js'));&#125;);/** * 使用gulp-concat合并javascript文件，减少网络请求。 */gulp.task('concatTask', function () &#123; gulp.src(['dist/js/*.js']) .pipe(plumber(&#123;errorHandler: notify.onError('Error: &lt;%= error.message %&gt;')&#125;)) // 错误提示 .pipe(concat('concatLibs.js')) // 合并成libs.js .pipe(rename(&#123; suffix: '.min' &#125;)) // 重命名 .pipe(gulp.dest('dist/js'))&#125;)/** * 文件复制 */gulp.task('copyTask', function () &#123; gulp.src('src/fonts/*') .pipe(gulp.dest('dist/fonts'))&#125;)/** * 清理文件 */gulp.task('cleanTask', function() &#123; var stream = gulp.src( 'dist', &#123;read: false&#125; ) // 清理maps文件 .pipe(clean()) return stream&#125;)/** * 注册任务 */gulp.task('webserver', ['htmlminTask'], function() &#123; gulp.src( 'dist' ) // 服务器目录（./代表根目录） .pipe(webserver(&#123; // 运行gulp-webserver livereload: true, // 启用LiveReload open: 'index.html', // 服务器启动时自动打开网页 port: 8089 // 服务端口 &#125;))&#125;)/** * 监听任务 */gulp.task('watch', function()&#123; // 监听 less gulp.watch( 'src/less/*.less' , ['lessTask']) // 监听 html gulp.watch( 'src/*.html' , ['htmlminTask']) // 监听 images gulp.watch( 'src/img/*.&#123;png,jpg,gif,ico&#125;' , ['pngquantTask']) // 监听 js gulp.watch( ['src/js/*.js','!src/js/*.min.js'] , ['uglifyTask']) // 监听 css gulp.watch( 'src/css/*.css' , ['cssverTask'])&#125;)/** * 默认任务 */gulp.task('default',[ 'htmlminTask', 'copyTask', 'cssverTask', 'uglifyTask', 'cacheTask', 'lessTask', 'webserver', 'watch']) 运行之后会生成一个dist目录，dist目录下的文件是通过配置gulp自动生成。 修改src目录下的任何文件都会自动刷新网页 插件汇总1、编译 gulp-sass - 通过 libsass将Sass编译成 CSS gulp-ruby-sass - 通过 Ruby Sass将Sass编译成CSS gulp-compass - 通过 Ruby Sass和CompassSass编译成CSS gulp-less - Less编译成 CSS. gulp-stylus - Stylus 编译成 CSS. gulp-postcss - Pipe CSS 通过 PostCSS processors with a single parse. gulp-coffee - Coffeescript 编译成 JavaScript. gulp-typescript - TypeScript编译成JavaScript. gulp-react - Facebook React JSX 模板编译成JavaScript. webpack-stream - 将webpack集成在Gulp中使用。 gulp-babel - ES6编译成ES5 通过 babel. gulp-traceur - ES6编译成ES5 通过 Traceur. gulp-regenerator - ES6编译成ES5 通过 Regenerator. gulp-es6-transpiler - [过时的] ES6编译成ES5 通过 es6-transpiler. gulp-myth - Myth - a polyfill for future versions of the CSS spec. gulp-cssnext - [过时的] 使用下一代的 CSS 规范通过 cssnext. 2、合并 gulp-concat - 合并文件. 3、压缩 gulp-clean-css - 压缩 CSS 通过 clean-css. gulp-csso - 压缩 CSS 通过 CSSO. gulp-uglify - 压缩 JavaScript 通过 UglifyJS2. gulp-htmlmin - 压缩 HTML 通过 html-minifier. gulp-minify-html - 压缩 HTML 通过 Minimize. gulp-imagemin - 压缩 PNG, JPEG, GIF and SVG 图片 通过 imagemin. gulp-svgmin - 通过Gulp压缩 SVG 文件 4、优化 gulp-uncss - 移除未使用的CSS选择器通过 UnCSS. gulp-css-base64 - 将CSS文件中所有的资源(有url()声明的)变成base64-encoded 数据的URI字符串 gulp-svg2png - 将SVGs转换成PNGs gulp-responsive - 生成不同尺寸的图片 gulp-svgstore -将svg files 合并成一个通过 元素 gulp-iconfont - 通过SVG icons创建 icon fonts 5、资源注入 gulp-useref - 解析HTML文件中特殊标签里面的script或style标签，合并成一个script或css文件，并替换。 gulp-inject - 将指定的css或js文件以标签的形式插入到HTML中的指定标志内。 wiredep - 将Bower依赖自动注入HTML文件中。 6、模板 gulp-angular-templatecache - 在$templateCache中联系并注册AngularJS模板 gulp-jade - Jade 转换成 HTML. gulp-handlebars - Handlebars模板转换成 JavaScript. gulp-hb - Handlebars 模板转换成 HTML. gulp-nunjucks - Nunjucks模板转换成JavaScript. gulp-dustjs - Dust模板转换成JavaScript. gulp-riot - Riot模板转换成JavaScript. gulp-markdown - Markdown → HTML. gulp-template - Lodash 模板转换成JavaScript. gulp-swig - Swig模板转换成HTML. gulp-remark - Gulp plugin for [remark]的Gulp插件(https://github.com/wooorm/remark) 通过插件处理markdown 7、代码校验 gulp-csslint - 通过CSSLint自动校验CSS. gulp-htmlhint - 通过HTMLHint校验HTML. gulp-jshint - 通过JSHint发现错误和潜在的问题. gulp-jscs - 通过jscs检查JavaScript代码风格. gulp-coffeelint - 一种用来保证CoffeeScript代码风格统一的检查。 gulp-tslint - gulp的TypeScript代码校验插件. gulp-eslint - ECMAScript/JavaScript代码校验. gulp-w3cjs - 通过w3cjs检验HTML. gulp-lesshint - 通过lesshint校验LESS. 8、实时加载 browser-sync - 保证多个浏览器或设备网页同步显示 (recipes). gulp-livereload - Gulp的实时加载插件. 9、缓存 gulp-changed - 仅让发生改变的文件通过. gulp-cached - 一个简单的文件内存缓存. gulp-remember - 记忆并回收通过了的文件. gulp-newer - 只让新的源码通过. 10、流控制 merge-stream - 合并多个流到一个插入的流. streamqueue - 逐渐输入队列的流. run-sequence - 按要求运行一些依赖的Gulptask. gulp-if - 按照条件运行task. 11、日志 gulp-notify - Gulp的通知插件. gulp-size - 显示你的项目的大小. gulp-debug - 通过调试文件流来观察那些文件通过了你的Gulp管道. 12、测试 gulp-mocha - 运行Mocha测试用例. gulp-jasmine - 在Node.js中运行Jasmine 2 测试用例. gulp-protractor - 为Protractor测试用例包裹Gulp. gulp-coverage - 为Node.js覆盖相对于运行的测试运行独立的报告. gulp-karma - 通过Gulp运行Karma测试用例. gulp-ava- 通过Gulp运行AVA 测试用例. 13、其他插件 gulp-util - 包含一系列有用插件. gulp-plumber - 防止错误引起管道中断Prevent pipe breaking caused by errors. gulp-load-plugins - 自动加载Gulp插件. main-bower-files - 构建时自动获取bower库的文件. autoprefixer - 解析CSS且根据规则添加浏览器兼容性前缀. gulp-sourcemaps - 提供source map支持. gulp-replace - Gulp的一个字符串替换插件. gulp-rename - 轻松重命名文件. gulp-rev - 在静态文件名的后面添加hash值，如: unicorn.css → unicorn-d41d8cd98f.css. del - 使用globs删除文件/文件夹. gulp-exec - 运行一个shell命令. gulp-strip-debug - 除去javascript代码中的console,alert,debugger声明. gulp-cssimport - 解析CSS文件，找到imports,将连接文件替换成imort声明. gulp-inline-css - 将HTML中的css属性放到style标签中. gulp-gh-pages - 将内容发布到GiHub有页面. gulp-ng-annotate - 通过ng-annotate添加Angular依赖注入. gulp-bump - 通过Gulp Bump任何semvar JSON版本. gulp-file-include - 通过Gulp Include文件. gulp-zip - 以ZIP格式压缩文件. gulp-git - 通过Gulp运行git命令. gulp-filter - 使用globbing过滤文件. gulp-preprocess - 基于自定义内容或环境配置预处理文件. 参考链接：http://www.cnblogs.com/-ding/p/5972162.html]]></content>
      <categories>
        <category>gulp</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CommonJS]]></title>
    <url>%2F2017%2F07%2F04%2FCommonJS%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;CommonJS API定义很多普通应用程序（主要指非浏览器的应用）使用的API，从而填补了这个空白。它的终极目标是提供一个类似Python，Ruby和Java标准库。这样的话，开发者可以使用CommonJS API编写应用程序，然后这些应用可以运行在不同的JavaScript解释器和不同的主机环境中。 在兼容CommonJS的系统中，你可以使用JavaScript开发以下程序： 服务器端JavaScript应用程序 命令行工具 图形界面应用程序 混合应用程序（如，Titanium或Adobe AIR） &emsp;&emsp;2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。这标志”Javascript模块化编程”正式诞生。因为老实说，在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。NodeJS是CommonJS规范的实现，webpack 也是以CommonJS的形式来书写。 1. 概述&emsp;&emsp;Node应用由模块组成，采用CommonJS模块规范。根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。 12345// example.jsvar x = 5;var addX = function (value) &#123; return value + x;&#125;; &emsp;&emsp;上面代码中，变量x和函数addX，是当前文件example.js私有的，其他文件不可见。如果想在多个文件分享变量，必须定义为global对象的属性。 1global.warning = true; &emsp;&emsp;上面代码的warning变量，可以被所有文件读取。当然，这样写法是不推荐的。 &emsp;&emsp;CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。123456var x = 5;var addX = function (value) &#123; return value + x;&#125;;module.exports.x = x;module.exports.addX = addX; &emsp;&emsp;上面代码通过module.exports输出变量x和函数addX。 require方法用于加载模块。1234var example = require('./example.js');console.log(example.x); // 5console.log(example.addX(1)); // 6 CommonJS模块的特点如下。 所有代码都运行在模块作用域，不会污染全局作用域。 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。 模块加载的顺序，按照其在代码中出现的顺序。 &emsp;&emsp;在 Node.js 中，创建一个模块非常简单，如下我们创建一个 ‘main.js’ 文件，代码如下:12var hello = require('./hello');hello.world(); &emsp;&emsp;以上实例中，代码 require(‘./hello’) 引入了当前目录下的hello.js文件（./ 为当前目录，node.js默认后缀为js）。 &emsp;&emsp;Node.js 提供了exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。 &emsp;&emsp;接下来我们就来创建hello.js文件，代码如下：123exports.world = function() &#123; console.log('Hello World');&#125; &emsp;&emsp;在以上示例中，hello.js 通过 exports 对象把 world 作为模块的访问接口，在 main.js 中通过 require(‘./hello’) 加载这个模块，然后就可以直接访问 hello.js 中 exports 对象的成员函数了。 &emsp;&emsp;有时候我们只是想把一个对象封装到模块中，格式如下：123module.exports = function() &#123; // ...&#125; 例如:1234567891011//hello.js function Hello() &#123; var name; this.setName = function(thyName) &#123; name = thyName; &#125;; this.sayHello = function() &#123; console.log('Hello ' + name); &#125;; &#125;; module.exports = Hello; 这样就可以直接获得这个对象了：12345//main.js var Hello = require('./hello'); hello = new Hello(); hello.setName('BYVoid'); hello.sayHello(); &emsp;&emsp;模块接口的唯一变化是使用 module.exports = Hello 代替了exports.world = function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。 2. module对象Node内部提供一个Module构建函数。所有模块都是Module的实例。12345function Module(id, parent) &#123; this.id = id; this.exports = &#123;&#125;; this.parent = parent; // ... 每个模块内部，都有一个module对象，代表当前模块。它有以下属性。 module.id 模块的识别符，通常是带有绝对路径的模块文件名。 module.filename 模块的文件名，带有绝对路径。 module.loaded 返回一个布尔值，表示模块是否已经完成加载。 module.parent 返回一个对象，表示调用该模块的模块。 module.children 返回一个数组，表示该模块要用到的其他模块。 module.exports 表示模块对外输出的值。 下面是一个示例文件，最后一行输出module变量。1234// example.jsvar jquery = require('jquery');exports.$ = jquery;console.log(module); 执行这个文件，命令行会输出如下信息。12345678910111213141516171819&#123; id: '.', exports: &#123; '$': [Function] &#125;, parent: null, filename: '/path/to/example.js', loaded: false, children: [ &#123; id: '/path/to/node_modules/jquery/dist/jquery.js', exports: [Function], parent: [Circular], filename: '/path/to/node_modules/jquery/dist/jquery.js', loaded: true, children: [], paths: [Object] &#125; ], paths: [ '/home/user/deleted/node_modules', '/home/user/node_modules', '/home/node_modules', '/node_modules' ]&#125; &emsp;&emsp;如果在命令行下调用某个模块，比如node something.js，那么module.parent就是undefined。如果是在脚本之中调用，比如require(‘./something.js’)，那么module.parent就是调用它的模块。利用这一点，可以判断当前模块是否为入口脚本。123456789if (!module.parent) &#123; // run with `node something.js` app.listen(8088, function() &#123; console.log('app listening on port 8088'); &#125;)&#125; else &#123; // used with `require('/.something.js')` module.exports = app;&#125; 2.1 module.exports属性&emsp;&emsp;module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。123456var EventEmitter = require('events').EventEmitter;module.exports = new EventEmitter();setTimeout(function() &#123; module.exports.emit('ready');&#125;, 1000); 上面模块会在加载后1秒后，发出ready事件。其他文件监听该事件，可以写成下面这样。1234var a = require('./a');a.on('ready', function() &#123; console.log('module a is ready');&#125;); 2.2 exports变量&emsp;&emsp;为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。1var exports = module.exports; 造成的结果是，在对外输出模块接口时，可以向exports对象添加方法。1234567exports.area = function (r) &#123; return Math.PI * r * r;&#125;;exports.circumference = function (r) &#123; return 2 * Math.PI * r;&#125;;` 注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。1exports = function(x) &#123;console.log(x)&#125;; 上面这样的写法是无效的，因为exports不再指向module.exports了。 下面的写法也是无效的。1234exports.hello = function() &#123; return 'hello';&#125;;module.exports = 'Hello world'; 上面代码中，hello函数是无法对外输出的，因为module.exports被重新赋值了。 这意味着，如果一个模块的对外接口，就是一个单一的值，不能使用exports输出，只能使用module.exports输出。123module.exports = function (x)&#123; console.log(x);&#125;; &emsp;&emsp;如果你觉得，exports与module.exports之间的区别很难分清，一个简单的处理方法，就是放弃使用exports，只使用module.exports。 3. require命令3.1 基本用法&emsp;&emsp;Node使用CommonJS模块规范，内置的require命令用于加载模块文.require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。12345678// example.jsvar invisible = function () &#123; console.log("invisible");&#125;exports.message = "hi";exports.say = function () &#123; console.log(message);&#125; 运行下面的命令，可以输出 exports对象,123456var example = require('./example.js');example// &#123;// message: "hi",// say: [Function]// &#125; &emsp;&emsp;如果模块输出的是一个函数，那就不能定义在exports对象上面，而要定义在module.exports变量上面。1234module.exports = function () &#123; console.log("hello world")&#125;require('./example2.js')() &emsp;&emsp;上面代码中，require命令调用自身，等于是执行module.exports，因此会输出 hello world。 3.2 加载规则&emsp;&emsp;require命令用于加载文件，后缀名默认为.js。123var foo = require('foo');// 等同于var foo = require('foo.js'); 根据参数的不同格式，require命令去不同路径寻找模块文件。 如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文件。比如，require(‘/home/marco/foo.js’)将加载/home/marco/foo.js。 如果参数字符串以“./”开头，则表示加载的是一个位于相对路径（跟当前执行脚本的位置相比）的模块文件。比如，require(‘./circle’)将加载当前脚本同一目录的circle.js。 如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块（位于Node的系统安装目录中），或者一个位于各级node_modules目录的已安装模块（全局安装或局部安装）。 &emsp;&emsp;举例来说，脚本/home/user/projects/foo.js执行了require(‘bar.js’)命令，Node会依次搜索以下文件。 /usr/local/lib/node/bar.js/home/user/projects/node_modules/bar.js/home/user/node_modules/bar.js/home/node_modules/bar.js/node_modules/bar.js&emsp;&emsp;这样设计的目的是，使得不同的模块可以将所依赖的模块本地化。 如果参数字符串不以“./“或”/“开头，而且是一个路径，比如require(‘example-module/path/to/file’)，则将先找到example-module的位置，然后再以它为参数，找到后续路径。 如果指定的模块文件没有发现，Node会尝试为文件名添加.js、.json、.node后，再去搜索。.js件会以文本格式的JavaScript脚本文件解析，.json文件会以JSON格式的文本文件解析，.node文件会以编译后的二进制文件解析。 如果想得到require命令加载的确切文件名，使用require.resolve()方法。 3.3 目录的加载规则&emsp;&emsp;通常，我们会把相关的文件会放在一个目录里面，便于组织。这时，最好为该目录设置一个入口文件，让require方法可以通过这个入口文件，加载整个目录。 &emsp;&emsp;在目录中放置一个package.json文件，并且将入口文件写入main字段。下面是一个例子。123// package.json&#123; "name" : "some-library", "main" : "./lib/some-library.js" &#125; &emsp;&emsp;require发现参数字符串指向一个目录以后，会自动查看该目录的package.json文件，然后加载main字段指定的入口文件。如果package.json文件没有main字段，或者根本就没有package.json文件，则会加载该目录下的index.js文件或index.node文件。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>CommonJS</tag>
        <tag>JavaScript</tag>
        <tag>requirejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown]]></title>
    <url>%2F2017%2F06%2F01%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 [ ] 支持以 PDF 格式导出文稿 [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 [x] 新增 Todo 列表功能 [x] 修复 LaTex 公式渲染问题 [x] 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序获取用户openid]]></title>
    <url>%2F2017%2F01%2F19%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7openid%2F</url>
    <content type="text"><![CDATA[1、wx.login(OBJECT) &nbsp; &nbsp;调用接口获取登录凭证（code）进而换取用户登录态信息，包括用户的唯一标识（openid） 及本次登录的 会话密钥（session_key）。用户数据的加解密通讯需要依赖会话密钥完成。 2、code 换取 session_key ​ &nbsp;这是一个 HTTPS 接口，开发者服务器使用登录凭证 code 获取 session_key 和 openid。其中 session_key 是对用户数据进行加密签名的密钥。为了自身应用安全，session_key 不应该在网络上传输。 接口地址： https://api.weixin.qq.com/sns/jscode2session?appid=APPID&amp;secret=SECRET&amp;js_code=JSCODE&amp;grant_type=authorization_code 详细的介绍请看小程序APIhttps://mp.weixin.qq.com/debug/wxadoc/dev/api/api-login.html#wxloginobject 3、获取用户openid实例 //app.js App({ globalData:{ appid:'1wqas2342dasaqwe2323424ac23qwe',//appid需自己提供，此处的appid我随机编写 secret:'e0dassdadef2424234209bwqqweqw123ccqwa',//secret需自己提供，此处的secret我随机编写 }, onLaunch: function () { var that = this var user=wx.getStorageSync('user') || {}; var userInfo=wx.getStorageSync('userInfo') || {}; if((!user.openid || (user.expires_in || Date.now()) &lt; (Date.now() + 600))&amp;&amp;(!userInfo.nickName)){ wx.login({ success: function(res){ if(res.code) { wx.getUserInfo({ success: function (res) { var objz={}; objz.avatarUrl=res.userInfo.avatarUrl; objz.nickName=res.userInfo.nickName; //console.log(objz); wx.setStorageSync('userInfo', objz);//存储userInfo } }); var d=that.globalData;//这里存储了appid、secret、token串 var l='https://api.weixin.qq.com/sns/jscode2session?appid='+d.appid+'&amp;secret='+d.secret+'&amp;js_code='+res.code+'&amp;grant_type=authorization_code'; wx.request({ url: l, data: {}, method: 'GET', // OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT // header: {}, // 设置请求的 header success: function(res){ var obj={}; obj.openid=res.data.openid; obj.expires_in=Date.now()+res.data.expires_in; //console.log(obj); wx.setStorageSync('user', obj);//存储openid } }); }else { console.log('获取用户登录态失败！' + res.errMsg) } } }); } }, })]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用nginx做node.js的反向代理]]></title>
    <url>%2F2017%2F01%2F04%2F%E7%94%A8nginx%E5%81%9Anode-js%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[1、安装nginx （1）、从nginx官网下载相应的安装包 &nbsp; &nbsp;下载地址：http://nginx.org。建议下稳定版 （2)、启动 解压至D:\Download\nginx-1.10.2，双击nginx.exe运行(或者通过控制台nginx -c conf\nginx.conf)，默认使用80端口，日志见文件夹D:\Download\nginx-1.10.2\logs （3)、使用 此时 直接在浏览器地址栏输入：http://localhost 便能看到 欢迎页面，说明你虚拟主机已经搭建好了 （4）、关闭 &nbsp; &nbsp;nginx -s stop&nbsp; （5）、配置Nginx &nbsp; &nbsp;进入conf 目录，在该目录下创建include 文件。进入 conf/include 目录，创建 nginx.node.conf 文件，在里面输入如下代码： upstream nodejs { server 127.0.0.1:3000; keepalive 64;} server { listen 80; server_name www.zmnode.com zmnode.com; location / { proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Nginx-Proxy true; proxy_set_header Connection &quot;&quot;; proxy_pass http://nodejs; } }进入conf ，打开nginx.conf, 在http 里面添加 include ./include/*。重启nginx , 输入 nginx -c conf/nginx.conf 在浏览器输入zmnode.com]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js中mysql数据库连接池]]></title>
    <url>%2F2017%2F01%2F04%2Fnode-js%E4%B8%ADmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[&nbsp; 在MySQL模块中，使用createPool方法创建连接池，在建立了连接池之后，可以直接使用连接池对象的getConnection方法从连接池中获取一个连接，如果连接池中没有可用连接，将隐式的建立一个数据库连接。 &nbsp; connection.release() 当一个连接不需要使用时，使用该方法将其归还到连接池中 &nbsp; connection.destroy() 当一个连接不需要使用且需要从连接池中移除时，可以使用该方法 &nbsp; pool.end() 当一个连接池不需要使用时，可以使用该方法关闭连接池 注意：可以使用createPool方法的属性connectionLimit设置连接池中的最大连接数，默认为10&nbsp;&nbsp; 1、安装node的mysql模块 npm install -g mysql &nbsp; 2、建立一个类库，就叫mysql.js吧，然后内容如下: &nbsp; var mysql=require(&quot;mysql&quot;);var pool = mysql.createPool({ host: ‘localhost’, user: ‘user’, password: ‘password’, database: ‘database’, port: 3306});var query=function(sql,callback){ pool.getConnection(function(err,conn){ if(err){ callback(err,null,null); }else{ conn.query(sql,function(err, result){ if(err){ &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; console.log(‘查询数据失败’); &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }else{ &nbsp;&nbsp; //释放连接 conn.release(); //事件驱动回调 callback(result);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; }); } }); }; module.exports=query; &nbsp; 3，在js类使用如下 &nbsp; var query=require(&quot;./lib/mysql.js&quot;); query(&quot;select 1 from 1&quot;,function(err,result){ //do something }); &nbsp;]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[supervisor与pm2]]></title>
    <url>%2F2017%2F01%2F04%2Fsupervisor%E4%B8%8Epm2%2F</url>
    <content type="text"><![CDATA[1、supervisor &nbsp; 在开发过程中，每次修改代码保存后，我们都需要手动重启程序，才能查看改动的效果。使用 supervisor 可以解决这个繁琐的问题，全局安装 supervisor。这里注意一点的就是，supervisor必须安装到全局，如果你不安装到全局，错误命令会提示你安装到全局。 &nbsp; npm install -g supervisor 运行 supervisor –harmony index 启动程序，如下所示： 安装完以后就可以用supervisor 来启动服务了。 supervisor www 启动完全是这个样子 输入网址启动请求如下图： 修改www文件然后请求如下图： 2、pm2 &nbsp; 当我们的项目要部署到线上服务器时，不能单纯的靠 node index 或者 supervisor index 来启动了，因为我们断掉 SSH 连接后服务就终止了，这时我们就需要像 pm2 或者 forever 这样的进程管理器了。pm2 是 Node.js 下的生产环境进程管理工具，就是我们常说的进程守护工具，可以用来在生产环境中进行自动重启、日志记录、错误预警等等。pm2官方文档：http://pm2.keymetrics.io/docs/usage/quick-start/ 以 pm2 为例，全局安装 pm2： &nbsp;首先需要安装pm2： &nbsp; &nbsp;npm install -g pm2 &nbsp;&nbsp; &nbsp;运行： &nbsp; &nbsp;pm2 start www.js 或者修改 package.json中的start命令： &quot;scripts&quot;: { &quot;start&quot;: &quot;pm2 start ./bin/www&quot; } 然后运行 npm start 通过 pm2 启动程序，如下图所示 ： pm2 常用命令: &nbsp;安装：npm install -g pm2 &nbsp;启动程序：pm2 start &lt;app_name|id|all&gt; &nbsp;列举进程：pm2 list &nbsp;退出程序：pm2 stop &lt;app_name|id|all&gt; &nbsp;重起应用：pm2 restart &nbsp;程序信息：pm2 describe id|all &nbsp;监控：pm2 monit &nbsp;实时集中log处理: pm2 logs &nbsp;API:pm2 web (端口：9615 ) 参考链接： &nbsp;&nbsp;nodejs高大上的部署方式-PM2 &nbsp; &nbsp; &nbsp; &nbsp;使用高大上的pm2代替forever部署nodejs项目 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;]]></content>
      <categories>
        <category>supervisor与pm2</category>
      </categories>
      <tags>
        <tag>supervisor与pm2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express 快速创建一个应用的骨架]]></title>
    <url>%2F2016%2F12%2F30%2Fexpress-%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%9A%84%E9%AA%A8%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[&nbsp; express 4.x以后将express命令独立到 express-generator包中，所以想使用express初始化项目目录，必须安装express-generator -h 选项可以列出所有可用的命令行选项： 例如，下面的示例就是在当前工作目录下创建一个命名为 myApp 的应用。 然后安装所有依赖包： 启动这个应用Windows 平台使用如下命令： 然后在浏览器中打开 http://localhost:3000/ 网址就可以看到这个应用了。 通过 Express 应用生成器创建的应用一般都有如下目录结构：]]></content>
      <categories>
        <category>express</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js Express 框架]]></title>
    <url>%2F2016%2F12%2F30%2FNode-js-Express-%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[&nbsp; Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。使用 Express 可以快速地搭建一个完整功能的网站。Express 框架核心特性：（1）、可以设置中间件来响应 HTTP 请求。（2）、定义了路由表用于执行不同的 HTTP 请求动作。（3）、可以通过向模板传递参数来动态渲染 HTML 页面。 已经在电脑D:\NodeProject\express目录下安装了express、body-parser、cookie-parser、express-generator、multer、mysql模块 1、请求和响应 Express 应用使用回调函数的参数： request 和 response 对象来处理请求和响应的数据。 以下实例中我们引入了express 模块，并在客户端发起请求后，响应字符串。 var express = require(‘../express/node_modules/express’);var app = express();app.get(‘/‘, function (req, res) {&nbsp; &nbsp;res.send(‘大家好！我是山水子农，正在学习express框架！’);})var server = app.listen(8081, function () {&nbsp; var host = server.address().address&nbsp; var port = server.address().port&nbsp; console.log(&quot;应用实例，访问地址为 http://%s:%s&amp;quot;, host, port) }) 执行以上代码： Request 对象 - request 对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP 头部等属性。常见属性有： （1）、req.app：当callback为外部文件时，用req.app访问express的实例 （2）、req.baseUrl：获取路由当前安装的URL路径 （3）、req.body / req.cookies：获得「请求主体」/ Cookies （4）、req.fresh / req.stale：判断请求是否还「新鲜」 （5）、req.hostname / req.ip：获取主机名和IP地址 （6）、req.originalUrl：获取原始请求URL （7）、req.params：获取路由的parameters （8）、req.path：获取请求路径 （9）、req.protocol：获取协议类型 （10）、req.query：获取URL的查询参数串 （11）、req.route：获取当前匹配的路由 （12）、req.subdomains：获取子域名 （13）、req.accpets（）：检查请求的Accept头的请求类型 （14）、req.acceptsCharsets / req.acceptsEncodings / req.acceptsLanguages （15）、req.get（）：获取指定的HTTP请求头 （16）、req.is（）：判断请求头Content-Type的MIME类型 Response 对象 - response 对象表示 HTTP 响应，即在接收到请求时向客户端发送的 HTTP 响应数据。常见属性有： （1）、res.app：同req.app一样 （2）、res.append（）：追加指定HTTP头 （3）、res.set（）在res.append（）后将重置之前设置的头 （4）、res.cookie（name，value [，option]）：设置Cookie （5）、opition: domain / expires / httpOnly / maxAge / path / secure / signed （6）、res.clearCookie（）：清除Cookie （7）、res.download（）：传送指定路径的文件 （8）、res.get（）：返回指定的HTTP头 （9）、res.json（）：传送JSON响应 （10）、res.jsonp（）：传送JSONP响应 （11）、res.location（）：只设置响应的Location HTTP头，不设置状态码或者close response （12）、res.redirect（）：设置响应的Location HTTP头，并且设置状态码302 （13）、res.send（）：传送HTTP响应 （14）、res.sendFile（path [，options] [，fn]）：传送指定路径的文件 -会自动根据文件extension设定Content-Type （15）、res.set（）：设置HTTP头，传入object可以一次设置多个头 （16）、res.status（）：设置HTTP状态码 （17）、res.type（）：设置Content-Type的MIME类型 2、路由 &nbsp; 我们已经了解了 HTTP 请求的基本应用，而路由决定了由谁(指定脚本)去响应客户端请求。在HTTP请求中，我们可以通过路由提取出请求的URL以及GET/POST参数。接下来我们扩展上例，添加一些功能来处理更多类型的 HTTP 请求。 var express = require(‘../express/node_modules/express’);var app = express();// 主页输出 &quot;Hello World&quot;app.get(‘/‘, function (req, res) { console.log(&quot;主页 GET 请求&quot;); res.send(‘Hello GET’);})// POST 请求app.post(‘/‘, function (req, res) { console.log(&quot;主页 POST 请求&quot;); res.send(‘Hello POST’);})// /del_user 页面响应app.get(‘/del_user’, function (req, res) { console.log(&quot;/del_user 响应 DELETE 请求&quot;); res.send(‘删除页面’);})// /list_user 页面 GET 请求app.get(‘/list_user’, function (req, res) { console.log(&quot;/list_user GET 请求&quot;); res.send(‘用户列表页面’);})// 对页面 abcd, abxcd, ab123cd, 等响应 GET 请求app.get(‘/abcd’, function(req, res) { console.log(&quot;/abcd GET 请求&quot;); res.send(‘正则匹配’);})var server = app.listen(8081, function () { var host = server.address().address var port = server.address().port console.log(&quot;应用实例，访问地址为 http://%s:%s&amp;quot;, host, port)}) 3、静态文件 &nbsp; Express 提供了内置的中间件 express.static 来设置静态文件如：图片， CSS, JavaScript 等。你可以使用 express.static 中间件来设置静态文件路径。例如，如果你将图片， CSS, JavaScript 文件放在 public 目录下，你可以这么写： app.use(express.static(‘public’));添加处理静态文件的代码如下所示： var express = require(‘../express/node_modules/express’);var app = express();app.use(express.static(‘public’));app.get(‘/‘, function (req, res) { res.send(‘大家好！我是山水子农，正在学习express的静态文件’);})var server = app.listen(8088, function () { var host = server.address().address var port = server.address().port console.log(&quot;应用实例，访问地址为 http://%s:%s&amp;quot;, host, port) }) 4、GET 方法 &nbsp; 以下实例演示了在表单中通过 GET 方法提交两个参数，我们可以使用 server.js 文件内的 process_get 路由器来处理输入， index.html 文件代码如下： &lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://127.0.0.1:8081/process_get&amp;quot; method=&quot;GET&quot;&gt;First Name: &lt;input type=&quot;text&quot; name=&quot;first_name&quot;&gt; &lt;br&gt;&lt;br&gt;Last Name: &lt;input type=&quot;text&quot; name=&quot;last_name&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;server.js 文件代码如下: var express = require('../express/node_modules/express'); var app = express(); //设置静态文件 app.use(express.static('public')); app.get('/index.htm', function (req, res) { //传送指定路径的文件 //__dirname 表示当前执行脚本所在的目录。 //__filename 表示当前正在执行的脚本的文件名。 &nbsp; &nbsp;res.sendFile( __dirname + &quot;/&quot; + &quot;index.html&quot; );//index.html路径D:\NodeProject\ExpressDemo\public\index.html }) app.get('/process_get', function (req, res) { &nbsp; &nbsp;// 输出 JSON 格式 &nbsp; &nbsp;response = { &nbsp; &nbsp; &nbsp; &nbsp;first_name:req.query.first_name,//req.query获取URL的查询参数串 &nbsp; &nbsp; &nbsp; &nbsp;last_name:req.query.last_name &nbsp; &nbsp;}; &nbsp; &nbsp;console.log(response); &nbsp; &nbsp;res.end(JSON.stringify(response));//传送HTTP响应 }) var server = app.listen(8081, function () { &nbsp; //server.address()操作系统返回绑定的地址，协议族名和服务器端口。 &nbsp; var host = server.address().address &nbsp; var port = server.address().port &nbsp; console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port) }) 执行以上代码： 5、POST 方法 &nbsp; 以下实例演示了在表单中通过 POST 方法提交两个参数，我们可以使用 serverPost.js 文件内的 process_post 路由器来处理输入。indexPost.htm 文件代码修改如下： &lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://127.0.0.1:8081/process_post&amp;quot; method=&quot;POST&quot;&gt;First Name: &lt;input type=&quot;text&quot; name=&quot;first_name&quot;&gt; &lt;br&gt;&lt;br&gt;Last Name: &lt;input type=&quot;text&quot; name=&quot;last_name&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;serverPost.js 文件代码修改如下 var express = require(‘../express/node_modules/express’);var app = express();var bodyParser = require(‘../express/node_modules/body-parser’);// 创建 application/x-www-form-urlencoded 编码解析var urlencodedParser = bodyParser.urlencoded({ extended: false })app.use(express.static(‘public’));app.get(‘/indexPost.htm’, function (req, res) { res.sendFile( __dirname + &quot;/&quot; + &quot;indexPost.htm&quot; );})app.post(‘/process_post’, urlencodedParser, function (req, res) { // 输出 JSON 格式 response = { first_name:req.body.first_name, last_name:req.body.last_name }; console.log(response); res.end(JSON.stringify(response));})var server = app.listen(8081, function () { var host = server.address().address var port = server.address().port console.log(&quot;应用实例，访问地址为 http://%s:%s&amp;quot;, host, port) }) 执行以上代码：]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node.js</tag>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js Web 模块]]></title>
    <url>%2F2016%2F12%2F30%2FNode-js-Web-%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[1、使用 Node 创建 Web 服务器 &nbsp; Node.js 提供了 http 模块，http 模块主要用于搭建 HTTP 服务端和客户端，使用 HTTP 服务器或客户端功能必须调用 http 模块，代码如下： var http = require(‘http’);以下是演示一个最基本的 HTTP 服务器架构(使用8081端口)，创建 server.js 文件，代码如下所示： var http = require('http'); var fs = require('fs'); var url = require('url'); // 创建服务器 http.createServer( function (request, response) { // 解析请求，包括文件名 var pathname = url.parse(request.url).pathname; // 输出请求的文件名 console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;); // 从文件系统中读取请求的文件内容 fs.readFile(pathname.substr(1), function (err, data) { if (err) { console.log(err); // HTTP 状态码: 404 : NOT FOUND // Content Type: text/plain response.writeHead(404, {'Content-Type': 'text/html'}); }else{ // HTTP 状态码: 200 : OK // Content Type: text/plain response.writeHead(200, {'Content-Type': 'text/html'}); // 响应文件内容 response.write(data.toString()); } // 发送响应数据 response.end(); }); }).listen(8081); // 控制台会输出以下信息 console.log('Server running at http://127.0.0.1:8081/');接下来我们在该目录下创建一个 index.htm 文件，代码如下： &lt;html&gt; &lt;head&gt; &lt;title&gt;Sample Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 执行 server.js 文件： 2、使用 Node 创建 Web 客户端 Node 创建 Web 客户端需要引入 http 模块，创建 client.js 文件，代码如下所示： var http = require(‘http’);// 用于请求的选项var options = { host: ‘localhost’, port: ‘8081’, path: ‘/index.htm’};// 处理响应的回调函数var callback = function(response){ // 不断更新数据 var body = ‘’; response.on(‘data’, function(data) { body += data; }); response.on(‘end’, function() { // 数据接收完成 console.log(body); });}// 向服务端发送请求var req = http.request(options, callback);req.end();新开一个终端，执行 client.js 文件，输出结果如下：]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js Path 模块]]></title>
    <url>%2F2016%2F12%2F30%2FNode-js-Path-%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[Node.js path 模块提供了一些用于处理文件路径的小工具，我们可以通过以下方式引入该模块： var path = require(&quot;path&quot;) 下面是path模块的实例： var path = require(&quot;path&quot;);// 格式化路径console.log(‘normalization : ‘ + path.normalize(‘/shanshuizinong/shanshuizinong1//2slashes/1slash/tab/..’));// 连接路径console.log(‘joint path : ‘ + path.join(‘/shanshuizinong’, ‘shanshuizinong1’, ‘2slashes/1slash’, ‘tab’, ‘..’));// 格式化路径去掉&quot;..&quot;console.log(‘normalization : ‘ + path.normalize(‘/shanshuizinong/shanshuizinong1//2slashes/1slash/tab’));// 连接路径去掉&quot;..&quot;console.log(‘joint path : ‘ + path.join(‘/shanshuizinong’, ‘shanshuizinong1’, ‘2slashes/1slash’, ‘tab’ ));// 转换为绝对路径var resolve=path.resolve(‘main.js’);console.log(‘resolve : ‘ + resolve);//判断是否为绝对路径console.log(‘isAbsolute :’+path.isAbsolute(resolve));//将相对路径转化为绝对路径console.log(‘relative :’+path.relative(&quot;main.js&quot;,&quot;D:\node&quot;));//返回路径中的最后一部分。console.log(&quot;basename ：&quot;+path.basename(‘D:\NodeProject\path\path.js’));// 路径中文件的后缀名console.log(‘extname : ‘ + path.extname(‘main.js’)); 1、路径解析，得到规范化的路径&#26684;式 对window系统，目录分隔为’\’, 对于UNIX系统，分隔符为’/‘，针对’..’返回上一级；/与\都被统一转换 path.normalize(p); console.log(‘normalization : ‘ + path.normalize(‘/shanshuizinong/shanshuizinong1//2slashes/1slash/tab/..’));2、路径结合、合并，路径最后不会带目录分隔符 path.join([path1],[path2]..[pathn]); console.log(‘joint path : ‘ + path.join(‘/shanshuizinong’, ‘shanshuizinong1’, ‘2slashes/1slash’, ‘tab’, ‘..’));3、获取绝对路径 以应用程序为起点，根据参数字符串解析出一个绝对路径 path.resolve(path1, [path2]..[pathn]); path 必须至少一个路径字符串&#20540; [pathn]可选路径字符串 var myPath = path.resolve(‘path1’, ‘path2’, ‘a/b\c/‘);console.log(myPath);//E:\workspace\NodeJS\path1\path2\a\b\c4、获取相对路径 获取两路径之间的相对关系 path.relative(from, to); from 当前路径，并且方法返回&#20540;是基于from指定到to的相对路径 to 到哪路径， console.log(‘relative :’+path.relative(&quot;main.js&quot;,&quot;D:\node&quot;));5、path.dirname(p) 获取路径中目录名 var myPath = path.dirname(__dirname + ‘/test/util you.mp3’);console.log(myPath);6、path.basename(path, [ext]) 获取路径中文件名,后缀是可选的，如果加，请使用’.ext’方式来匹配，则返回&#20540;中不包括后缀名； var myPath = path.basename(__dirname + ‘/test/util you.mp3’, ‘.mp3’);console.log(myPath);7、path.extname(path) 获取路径中的扩展名，如果没有’.’，则返回空 console.log(‘extname : ‘ &#43; path.extname(‘main.js’));]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js GET/POST请求]]></title>
    <url>%2F2016%2F12%2F30%2FNode-js-GET-POST%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[1、获取GET请求内容 &nbsp; 由于GET请求直接被嵌入在路径中，URL是完整的请求路径，包括了?后面的部分，因此你可以手动解析后面的内容作为GET请求的参数。node.js中url模块中的parse函数提供了这个功能。我们可以使用 url.parse 方法来解析 URL 中的参数，代码如下： var http = require(‘http’);var url = require(‘url’);http.createServer(function(req, res){ res.writeHead(200, {‘Content-Type’: ‘text/plain’}); // 解析 url 参数 var params = url.parse(req.url, true).query; res.write(&quot;用户名：&quot; + params.username); res.write(&quot;\n&quot;); res.write(&quot;密 码：&quot; + params.password); res.end(); }).listen(80); ** ** 2、获取 POST 请求内容 &nbsp; &nbsp;POST 请求的内容全部的都在请求体中，http.ServerRequest 并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。比如上传文件，而很多时候我们可能并不需要理会请求体的内容，恶意的POST请求会大大消耗服务器的资源，所有node.js 默认是不会解析请求体的，当你需要的时候，需要手动来做。以下实例表单通过 POST 提交并输出数据： var http = require(‘http’);var querystring = require(‘querystring’); var postHTML = ‘&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程 Node.js 实例&lt;/title&gt;&lt;/head&gt;’ + ‘&lt;body&gt;’ + ‘&lt;form method=&quot;post&quot;&gt;’ + ‘网站名： &lt;input name=&quot;name&quot;&gt;&lt;br&gt;’ + ‘网站 URL： &lt;input name=&quot;url&quot;&gt;&lt;br&gt;’ + ‘&lt;input type=&quot;submit&quot;&gt;’ + ‘&lt;/form&gt;’ + ‘&lt;/body&gt;&lt;/html&gt;’; http.createServer(function (req, res) { var body = &quot;&quot;; // 通过req的data事件监听函数，每当接受到请求体的数据，就累加到body变量中 req.on(‘data’, function (chunk) { body += chunk; }); // 在end事件触发后，通过querystring.parse将body解析为真正的POST请求格式，然后向客户端返回。 req.on(‘end’, function () { // 解析参数 body = querystring.parse(body); // 设置响应头部信息及编码 res.writeHead(200, {‘Content-Type’: ‘text/html; charset=utf8’}); if(body.name &amp;amp;&amp;amp; body.url) { // 输出提交的数据 res.write(&amp;quot;用户名：&amp;quot; + body.name); res.write(&amp;quot;&amp;lt;br&amp;gt;&amp;quot;); res.write(&amp;quot;密 码：&amp;quot; + body.url); } else { // 输出表单 res.write(postHTML); } res.end(); });}).listen(80);]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node.js</tag>
        <tag>GET/POST请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js 路由]]></title>
    <url>%2F2016%2F12%2F30%2FNode-js-%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[&nbsp; &nbsp; 我们要为路由提供请求的URL和其他需要的GET及POST参数，随后路由需要根据这些数据来执行相应的代码。因此，我们需要查看HTTP请求，从中提取出请求的URL以及GET/POST参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实&#20540;得探讨，但这里暂定其为我们的HTTP服务器的功能。我们需要的所有数据都会包含在request对象中，该对象作为onRequest()回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，它们分别是url和querystring模块。 现在我们可以来编写路由了，建立一个名为 router.js 的文件，添加以下内容： function route(pathname) { console.log(&quot;About to route a request for &quot; + pathname);}exports.route = route;如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。 &nbsp; &nbsp; &nbsp;我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块。 首先，我们来扩展一下服务器的start()函数，以便将路由函数作为参数传递过去，server.js 文件代码如下 var http = require(&quot;http&quot;);var url = require(&quot;url&quot;);function start(route) { function onRequest(request, response) { var pathname = url.parse(request.url).pathname; console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;); route(pathname); response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;}); response.write(&quot;大家好！我是山水子农，正在学习Node.js&quot;); response.end(); } http.createServer(onRequest).listen(8888); console.log(&quot;Server has started.&quot;);}exports.start = start;同时，我们会相应扩展index.js，使得路由函数可以被注入到服务器中： var server = require(&quot;./server&quot;);var router = require(&quot;./router&quot;);server.start(router.route);在这里，我们传递的函数依旧什么也没做。如果现在启动应用（node index.js，始终记得这个命令行），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由： 浏览器访问 http://127.0.0.1:8888/?username=sanshuizinong&amp;password=123456，输出结果如下：]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Html的空格显示]]></title>
    <url>%2F2016%2F12%2F18%2FHtml%E7%9A%84%E7%A9%BA%E6%A0%BC%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[一、使用全角空&#26684; 全角空&#26684;被解释为汉字，所以不会被被解释为HTML分隔符，可以按照实际的空&#26684;数显示。 二、使用空&#26684;的替代符号 替代符号就是在需要显示空&#26684;的地方加入替代符号，这些符号会被浏览器解释为空&#26684;显示。 空&#26684;的替代符号有以下几种： 名称编号描述&amp;nbsp;&amp;#160;不断行的空白（1个字符宽度）&amp;ensp;&amp;#8194;半个空白（1个字符宽度）&amp;emsp;&amp;#8195;一个空白（2个字符宽度）&amp;thinsp;&amp;#8201;窄空白（小于1个字符宽度） 可以用名称或编号作为空&#26684;的替代符号，名称必须小写，末尾的“;”不能省略。 如： 欢&amp;nbsp;&amp;nbsp;迎&amp;nbsp;&amp;nbsp;光&amp;nbsp;&amp;nbsp;临！ 显示效果为：欢&nbsp; 迎&nbsp; 光&nbsp; 临！ 三、使用CSS的 white-space 属性 CSS的white-space属性用于设置文本中空&#26684;的处理方式，当white-space属性取&#20540;为pre时，浏览器会保留文本中的空&#26684;和换行，这样你就可以直接在文本中使用空&#26684;和回车了。 这种方法特别适合于在网页中显示程序代码。比如：显示一段C程序代码。 &lt;div style=&quot;white-space:pre&quot;&gt;int sub(int x,int y){&nbsp;&nbsp;&nbsp; int z;&nbsp;&nbsp;&nbsp; if( x&amp;gt;y )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z = x-y;&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z = y-x;&nbsp;&nbsp;&nbsp; return z;}&lt;/div&gt; 显示效果为： int sub(int x,int y){&nbsp;&nbsp;&nbsp; int z;&nbsp;&nbsp;&nbsp; if( x&gt;y )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z = x-y;&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z = y-x;&nbsp;&nbsp;&nbsp; return z;} 使用HTML的&lt;pre&gt;标签也可以达到类&#20284;的效果，但&lt;pre&gt;标签有一些不太好的特性，不如使用CSS的white-space属性更方便。 四、使用CSS的 letter-spacing 属性 CSS的letter-spacing属性用于设置文本中字符之间的间隔，它的取&#20540;可以是一个带单位的长度&#20540;，浏览器会在字和字之间设置指定长度的空白。比如： &lt;div style=&quot;letter-spacing:30px&quot;&gt;欢迎光临！&lt;/div&gt; 显示效果为： 欢迎光临！ 注意，如果文本中有英文单词，则空白会加在字母之间，而不是单词之间。 五、使用CSS的 word-spacing 属性 CSS的word-spacing属性用于设置文本中单词之间的间隔，它的取&#20540;可以是一个带单位的长度&#20540;，浏览器会在单词和单词之间设置指定长度的空白。比如： &lt;div style=&quot;word-spacing:30px&quot;&gt;Happy new year!&lt;/div&gt; 显示效果为： Happy new year! 注意，HTML是以空&#26684;来区分单词的，它会把单词间的空白按指定长度显示。 六、使用CSS的 text-indent 属性 CSS的text-indent属性用于设置首行缩进，它的取&#20540;可以是一个带单位的长度&#20540;，浏览器会在段落的首行开始处设置指定长度的空白。比如： &lt;div style=&quot;text-indent:2em&quot;&gt;欢迎光临！&lt;/div&gt; 显示效果为： 欢迎光临！ 说明：em 是一个相对长度单位，2em 表示要缩进两个字的距离。]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[checkbox利用JQuer中 attr设置状态只有第一次有用]]></title>
    <url>%2F2016%2F12%2F18%2Fcheckbox%E5%88%A9%E7%94%A8JQuer%E4%B8%AD-attr-39-checked-39-true-%E8%AE%BE%E7%BD%AE%E7%8A%B6%E6%80%81%E5%8F%AA%E6%9C%89%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%9C%89%E7%94%A8%2F</url>
    <content type="text"><![CDATA[&nbsp; 在JQuery中可以使用attr()来访问对象的属性，但是在某些时候，比如访问input的disabled属性的时候，会有些问题。在有的浏览器中，只要写了disabled属性就可以，有的则要写：disabled=&quot;disabled&quot;。所以JQuery提供了新的方法prop()来获取这些属性，使用prop()的时候，返回&#20540;是标准属性：true/false，不会回返“disabled”或者“”。那么，那些属性应该使用attr()访问，哪些应该用prop()访问呢？ 第一个原则：只添加属性名称该属性就会生效的应该使用prop()； 第二个原则：只存在true/false的属性应该使用prop()。 像如果是设置disabled或者checked这些属性，应该使用prop()方法，而不是使用attr()方法。 &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;复选框应用&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.10.2.min.js&quot; &gt;&lt;/script&gt; &lt;style&gt; .checkbox{ border: 1px solid #A9A9A9; margin: 10px auto; padding: 10px 10px; } &lt;/style&gt; &lt;script&gt; $(function(){ //全选 $(&quot;#CheckedAll&quot;).click(function(){ //$(&quot;[name=items]:checkbox&quot;).attr(‘checked’,true);//只有第一次生效 $(&quot;[name=items]:checkbox&quot;).prop(‘checked’,true);//只有第一次生效 }); //全不选 $(&quot;#CheckedNo&quot;).click(function(){ //$(&quot;[name=items]:checkbox&quot;).attr(‘checked’,false);//只有第一次生效 $(&quot;[name=items]:checkbox&quot;).prop(‘checked’,false); }); //反选 $(&quot;#CheckedRev&quot;).click(function(){ $(&quot;[name=items]:checkbox&quot;).each(function(){ this.checked=!this.checked; }) }); //提交 $(&quot;#send&quot;).click(function(){ var str=&quot;你选中的是：\r\n&quot;; $(&quot;[name=items]:checked&quot;).each(function(){ str+=$(this).val()+&quot;\r\n&quot;; }) alert(str); }); //全选/全不选 $(&quot;#CheckedAN&quot;).click(function(){ $(&quot;[name=items]:checkbox&quot;).prop(&quot;checked&quot;,this.checked); }) //当复选框取消某一个选项的选中状态是时，全选/全不选需要取消选中状态 $(&quot;[name=items]:checkbox&quot;).click(function(){ var tmp=$(&quot;[name=items]:checkbox&quot;); $(&quot;#CheckedAN&quot;).prop(&quot;checked&quot;,tmp.length==tmp.filter(&quot;:checked&quot;).length); }) }) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot; id=&quot;regForm&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;复选框应用&lt;/legend&gt; &lt;div class=&quot;checkbox&quot;&gt; 你爱好的运动是？ &lt;input type=&quot;checkbox&quot; id=&quot;CheckedAN&quot; value=&quot;全选/全不选&quot;/&gt;全选/全不选 &lt;br /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;足球&quot;/&gt;足球 &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;篮球&quot;/&gt;篮球 &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;羽毛球&quot; /&gt;羽毛球 &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;乒乓球&quot; /&gt;乒乓球 &lt;br /&gt; &lt;input type=&quot;button&quot; id=&quot;CheckedAll&quot; value=&quot;全选&quot;/&gt; &lt;input type=&quot;button&quot; id=&quot;CheckedNo&quot; value=&quot;全不选&quot;/&gt; &lt;input type=&quot;button&quot; id=&quot;CheckedRev&quot; value=&quot;反选&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;send&quot; value=&quot;提交&quot; /&gt; &lt;/div&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JQuery</tag>
        <tag>checkbox</tag>
        <tag>attr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[layer.js]]></title>
    <url>%2F2016%2F12%2F15%2Flayer-js%2F</url>
    <content type="text"><![CDATA[1、、基础参数 &nbsp; 我们提到的基础参数主要指调用方法时用到的配置项，如：layer.open({content: ‘’})layer.msg(‘’, {time: 3})等，其中的content和time即是基础参数，以键&#20540;形式存在，基础参数可合理应用于任何层类型中，您不需要所有都去配置，大多数都是可选的。而其中的layer.open、layer.msg就是内置方法。注意，从2.3开始，无需通过layer.config来加载拓展模块 （1）、type - 基本层类型 &nbsp; 类型：Number，默认：0 &nbsp; layer提供了5种层类型。可传入的&#20540;有：0（信息框，默认）1（页面层）2（iframe层）3（加载层）4（tips层）。若你采用layer.open({type: 1})方式调用，则type为必填项（信息框除外） （2）、title - 标题 &nbsp; 类型：String/Array/Boolean，默认：’信息’ &nbsp; title支持三种类型的&#20540;，若你传入的是普通的字符串，如title :’我是标题’，那么只会改变标题文本；若你还需要自定义标题区域样式，那么你可以title: [‘文本’, ‘font-size:18px;’]，数组第二项可以写任意css样式；如果你不想显示标题栏，你可以title: false （3）、content - 内容 类型：String/DOM/Array，默认：’’ content可传入的&#20540;是灵活多变的，不仅可以传入普通的html内容，还可以指定DOM，更可以随着type的不同而不同。譬如： /!* 如果是页面层 */ layer.open({ type: 1, content: '传入任意的文本或html' //这里content是一个普通的String }); layer.open({ type: 1, content: $('#id') //这里content是一个DOM }); //Ajax获取 $.post('url', {}, function(str){ layer.open({ type: 1, content: str //注意，如果str是object，那么需要字符拼接。 }); }); /!* 如果是iframe层 */ layer.open({ type: 2, content: 'http://sentsin.com' //这里content是一个URL，如果你不想让iframe出现滚动条，你还可以content: ['http://sentsin.com', 'no'] }); /!* 如果是用layer.open执行tips层 */ layer.open({ type: 4, content: ['内容', '#id'] //数组第二项即吸附元素选择器或者DOM }); **（4）、skin - 样式类名** &nbsp; 类型：String，默认：'' &nbsp; skin不仅允许你传入layer内置的样式class名，还可以传入您自定义的class名。这是一个很好的切入点，意味着你可以借助skin轻松完成不同的风&#26684;定制。目前layer内置的skin有：layui-layer-lan、layui-layer-molv，未来我们还会选择性地内置更多，但更推荐您自己来定义。 **（5）、area - 宽高** &nbsp; 类型：String/Array，默认：'auto' &nbsp; 在默认状态下，layer是宽高都自适应的，但当你只想定义宽度时，你可以area: '500px'，高度仍然是自适应的。当你宽高都要定义时，你可以area: ['500px', '300px'] **（6）、offset - 坐标** &nbsp; 类型：String/Array，默认：垂直水平居中 &nbsp; offset默认情况下不用设置。但如果你不想垂直水平居中，你还可以进行以下赋&#20540;： ![](http://img.blog.csdn.net/20161215194647384?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjc2MjYzMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center) **（7）、icon - 图标。信息框和加载层的私有参数** &nbsp; 类型：Number，默认：-1（信息框）/0（加载层） &nbsp; 信息框默认不显示图标。当你想显示图标时，默认皮肤可以传入0-6，如果是加载层，可以传入0-2。 **（8）、btn - 按钮** &nbsp; 类型：String/Array，默认：'确认' &nbsp; 信息框模式时，btn默认是一个确认按钮，其它层类型则默认不显示，加载层和tips层则无效。当您只想自定义一个按钮时，你可以btn: '我知道了'，当你要定义两个按钮时，你可以btn: ['yes', 'no']。当然，你也可以定义更多按钮，比如：btn: ['按钮1', '按钮2', '按钮3', …]，按钮1和按钮2的回调分别是yes和cancel，而从按钮3开始，则回调为btn3: function(){}，以此类推。 **（9）、btnAlign - 按钮排列** &nbsp; 类型：String，默认：r &nbsp; 你可以快捷定义按钮的排列位置，btnAlign的默认&#20540;为r，即右对齐。btnAlign: 'l'，按钮左对齐；btnAlign: 'c'，按钮居中对齐。 **（10）、closeBtn - 关闭按钮** &nbsp; 类型：String/Boolean，默认：1 &nbsp; layer提供了两种风&#26684;的关闭按钮，可通过配置1和2来展示，如果不显示，则closeBtn: 0 **（11）、shade - 遮罩** &nbsp; 类型：String/Array/Boolean，默认：0.3 &nbsp; 即弹层外区域。默认是0.3透明度的黑色背景（'#000'）。如果你想定义别的颜色，可以shade: [0.8, '#393D49']；如果你不想显示遮罩，可以shade: 0 **（12）shadeClose - 是否点击遮罩关闭** &nbsp; 类型：Boolean，默认：false &nbsp; 如果你的shade是存在的，那么你可以设定shadeClose来控制点击弹层外区域关闭。 **（13）、time - 自动关闭所需毫秒** &nbsp; 类型：Number，默认：0 &nbsp; 默认不会自动关闭。当你想自动关闭时，可以time: 5000，即代表5秒后自动关闭，注意单位是毫秒（1秒=1000毫秒） **（14）、id - 用于控制弹层唯一标识** &nbsp; 类型：String，默认：空字符 &nbsp; 设置该&#20540;后，不管是什么类型的层，都只允许同时弹出一个。一般用于页面层和iframe层模式 **（15）anim - 动画** &nbsp; 类型：Number，默认：0 &nbsp; 我们的出场动画全部采用CSS3。这意味着除了ie6-9，其它所有浏览器都是支持的。目前anim可支持的动画类型有0-6 ，（请注意，3.0之前的版本用的 shift 参数） **（16）maxmin - 最大最小化。** &nbsp; 类型：Boolean，默认：false &nbsp; 该参数&#20540;对type:1和type:2有效。默认不显示最大小化按钮。需要显示配置maxmin: true即可 **（17）fixed - 固定** &nbsp; 类型：Boolean，默认：true &nbsp; 即鼠标滚动时，层是否固定在可视区域。如果不想，设置fixed: false即可 **（18）、resize - 是否允许拉伸** &nbsp; 类型：Boolean，默认：true &nbsp; 默认情况下，你可以在弹层右下角拖动来拉伸尺寸。如果对指定的弹层屏蔽该功能，设置 false即可。该参数对loading、tips层无效 **（19）、scrollbar - 是否允许浏览器出现滚动条** &nbsp; 类型：Boolean，默认：true &nbsp; 默认允许浏览器滚动，如果设定scrollbar: false，则屏蔽 **（20）、maxWidth - 最大宽度** &nbsp; 类型：，默认：360 &nbsp; 请注意：只有当area: 'auto'时，maxWidth的设定才有效。 **（21）、zIndex - 层叠顺序** &nbsp; 类型：，默认：19891014（贤心生日 0.0） &nbsp; 一般用于解决和其它组件的层叠冲突。 **（22）、move - 触发拖动的元素** &nbsp; 类型：String/DOM/Boolean，默认：'.layui-layer-title' &nbsp; 默认是触发标题区域拖拽。如果你想单独定义，指向元素的选择器或者DOM即可。如move: '.mine-move'。你还配置设定move: false来禁止拖拽 **（23）、moveOut - 是否允许拖拽到窗口外** &nbsp; 类型：Boolean，默认：false &nbsp; 默认只能在窗口内拖拽，如果你想让拖到窗外，那么设定moveOut: true即可 **（24）、moveEnd - 拖动完毕后的回调方法** &nbsp; 类型：Function，默认：null &nbsp; 默认不会触发moveEnd，如果你需要，设定moveEnd: function(){}即可。 **（25）、tips - tips方向和颜色** &nbsp; 类型：Number/Array，默认：2 &nbsp; tips层的私有参数。支持上右下左四个方向，通过1-4进行方向设定。如tips: 3则表示在元素的下面出现。有时你还可能会定义一些颜色，可以设定tips: [1, '#c00'] **（26）、tipsMore - 是否允许多个tips** &nbsp; 类型：Boolean，默认：false &nbsp; 允许多个意味着不会销毁之前的tips层。通过tipsMore: true开启 **（27）、success - 层弹出后的成功回调方法** &nbsp; 类型：Function，默认：null &nbsp; 当你需要在层创建完毕时即执行一些语句，可以通过该回调。success会携带两个参数，分别是当前层DOM当前层索引。 **（28）、yes - 确定按钮回调方法** &nbsp; 类型：Function，默认：null &nbsp; 该回调携带两个参数，分别为当前层索引、当前层DOM对象。 layer.open({ content: '测试回调', yes: function(index, layero){ //do something layer.close(index); //如果设定了yes回调，需进行手工关闭 } }); **（29）、cancel - 右上角关闭按钮触发的回调** &nbsp; 类型：Function，默认：null &nbsp; 该回调同样只携带当前层索引一个参数，无需进行手工关闭。如果不想关闭，return false即可， //只有当点击confirm框的确定时，该层才会关闭 cancel: function(index){ if(confirm('确定要关闭么')){ layer.close(index) } return false; } **（30）、end - 层销毁后触发的回调** &nbsp; 类型：Function，默认：null &nbsp; 无论是确认还是取消，只要层被销毁了，end都会执行，不携带任何参数。 **（31）、full/min/restore -分别代表最大化、最小化、还原 后触发的回调** &nbsp; 类型：Function，默认：null &nbsp; 携带一个参数，即当前层DOM **2、实例** &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;layer-更懂你的web弹窗解决方案&lt;/title&gt; &lt;script src=&quot;layer/jquery-1.10.2.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;layer/layer.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;layer/skin/default/layer.css&quot; /&gt; &lt;style&gt; div.conten{ width: 100%; border: 2px solid #C9C5C5; margin-bottom: 10px; box-shadow: 5px 5px #CCCCCC; text-align: center; } button.bt{ width: 100px; height: 40px; line-height: 40px; background-color:#2D93CA; border-radius: 10px; color:white; text-align: center; font-weight: bold; font-size: 15px; } .layer_notice{ margin-bottom: 10px; text-align: center; width:200px; color: #999999; margin: 0px auto; } .layer-photos-demo{ text-align: center; width:500px; color: #999999; margin: 0px auto; border: 2px solid #C9C5C5; margin-bottom: 10px; box-shadow: 5px 5px #CCCCCC; } body .demo-class .layui-layer-demo{background:#333;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;conten&quot;&gt; &lt;button onclick=&quot;common(1)&quot; class=&quot;bt&quot;&gt;普通信息框&lt;/button&gt; &lt;button onclick=&quot;common(2)&quot; class=&quot;bt&quot;&gt;图标&lt;/button&gt; &lt;button onclick=&quot;common(3)&quot; class=&quot;bt&quot;&gt;询问框&lt;/button&gt; &lt;button onclick=&quot;common(4)&quot; class=&quot;bt&quot;&gt;提示层&lt;/button&gt; &lt;button onclick=&quot;common(5)&quot; class=&quot;bt&quot;&gt;墨绿深蓝风&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;conten&quot;&gt; &lt;button onclick=&quot;common(6)&quot; class=&quot;bt&quot;&gt;捕获页&lt;/button&gt; &lt;button onclick=&quot;common(7)&quot; class=&quot;bt&quot;&gt;页面层&lt;/button&gt; &lt;button onclick=&quot;common(8)&quot; class=&quot;bt&quot;&gt;自定页&lt;/button&gt; &lt;button onclick=&quot;common(9)&quot; class=&quot;bt&quot; &gt;tips层&lt;/button&gt; &lt;button onclick=&quot;common(10)&quot; class=&quot;bt&quot;&gt;iframe层&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;conten&quot;&gt; &lt;button onclick=&quot;common(11)&quot; class=&quot;bt&quot;&gt;iframe窗&lt;/button&gt; &lt;button onclick=&quot;common(12)&quot; class=&quot;bt&quot;&gt;加载层&lt;/button&gt; &lt;button onclick=&quot;common(13)&quot; class=&quot;bt&quot;&gt;loading层&lt;/button&gt; &lt;button onclick=&quot;common(14)&quot; class=&quot;bt&quot;&gt;小tips&lt;/button&gt; &lt;button onclick=&quot;common(15)&quot; class=&quot;bt&quot;&gt;prompt层&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;conten&quot;&gt; &lt;button onclick=&quot;common(16)&quot; class=&quot;bt&quot;&gt;tap层&lt;/button&gt; &lt;button onclick=&quot;common(17)&quot; class=&quot;bt&quot;&gt;相册层&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot; layer_notice&quot;&gt;傲不可长，欲不可纵，乐不可极，志不可满。&lt;/div&gt; &lt;div id=&quot;layer-photos-demo&quot; class=&quot;layer-photos-demo&quot;&gt; &lt;img layer-pid=&quot;图片id，可以不写&quot; layer-src=&quot;img/1.jpg&quot; src=&quot;img/11.jpg&quot; alt=&quot;图片名&quot;&gt; &lt;img layer-pid=&quot;图片id，可以不写&quot; layer-src=&quot;img/2.jpg&quot; src=&quot;img/22.jpg&quot; alt=&quot;图片名&quot;&gt; &lt;img layer-pid=&quot;图片id，可以不写&quot; layer-src=&quot;img/4.jpg&quot; src=&quot;img/44.jpg&quot; alt=&quot;图片名&quot;&gt; &lt;img layer-pid=&quot;图片id，可以不写&quot; layer-src=&quot;img/5.jpg&quot; src=&quot;img/55.jpg&quot; alt=&quot;图片名&quot;&gt; &lt;img layer-pid=&quot;图片id，可以不写&quot; layer-src=&quot;img/7.jpg&quot; src=&quot;img/77.jpg&quot; alt=&quot;图片名&quot;&gt; &lt;/div&gt; &lt;script&gt; function common(n){ if(n==1){ //layer.alert(content, options, yes) - 普通信息框 layer.alert('有了回调', {title:'提示'},function(index){ layer.alert('加了个图标', {icon: 1},function(index){ layer.alert('只想简单的提示',function(index){ layer.close(index);//没有close就需要手动关闭 }); }); }); }else if(n==2){ //图标 layer.alert('图标0', {icon: 0},function(index){ layer.alert('图标'+index, {icon: 1},function(index){ layer.alert('图标'+index, {icon: 2},function(index){ layer.alert('图标'+index, {icon: 3},function(index){ layer.alert('图标'+index, {icon: 4},function(index){ layer.alert('图标'+index, {icon: 5},function(index){ layer.alert('图标'+index, {icon: 6},function(index){ layer.close(index); }) }) }) }) }) }) }) }else if(n==3){ //layer.confirm(content, options, yes, cancel) - 询问框 layer.confirm('您是如何看待前端开发？', { btn: ['重要','奇葩'], //按钮 icon: 3, title:'提示' }, function(){ layer.msg('的确很重要', {icon: 1}); }, function(){ layer.msg('也可以这样', { time: 20000, //20s后自动关闭 btn: ['明白了', '知道了'] }); }); }else if(n==4){ //layer.msg(content, options, end) - 提示框，3秒后自动消失 layer.msg('玩命提示中',{ icon: 1, time: 2000 //2秒关闭（如果不配置，默认是3秒） }, function(){ layer.msg('呵呵'); }); }else if(n==5){ //墨绿深蓝风 layer.alert('墨绿风格，点击确认看深蓝', { skin: 'layui-layer-molv', //样式类名 closeBtn: 0//layer提供了两种风格的关闭按钮 }, function(){ layer.alert('深蓝style', { skin: 'layui-layer-lan', closeBtn: 0,//layer提供了两种风格的关闭按钮 anim: 4 //动画类型 }); }); }else if(n==6){ //捕获页 layer.open({ type: 1, shade: false, area: ['420px', '240px'], //宽高 title: false, //不显示标题 content: $('.layer_notice'), //捕获的元素 cancel: function(){ layer.msg('捕获就是从页面已经存在的元素上，包裹layer的结构', { time: 5000, icon:6 }); } }); }else if(n==7){ //页面层 layer.open({ type: 1, skin: 'layui-layer-rim', //加上边框 area: ['420px', '240px'], //宽高 content: 'html内容' }); }else if(n==8){ //自定页 layer.open({ type: 1, skin: 'layui-layer-demo', //样式类名 closeBtn: 0, //不显示关闭按钮 anim: 2,//anim可支持的动画类型有0-6 shadeClose: true, //开启遮罩关闭 content: '内容' }); }else if(n==9){ //tips层 layer.tips('Hi，我是tips', '.layer_notice',{tips:2}); }else if(n==10){ //iframe层 layer.open({ type: 2, title: 'layer mobile页', shadeClose: true,//是否点击遮罩关闭 shade:[0.8,'#393D49'],//遮罩 area: ['380px', '90%'], content: 'http://blog.csdn.net/qq_27626333/article/details/53674829' //iframe的url }); }else if(n==11){ //iframe窗 layer.open({ type: 2, title: false, closeBtn: 0, //不显示关闭按钮 shade: [0],//不显示遮罩 area: ['340px', '215px'], offset: 'rb', //右下角弹出 time: 2000, //2秒后自动关闭 anim: 2, content: ['http://blog.csdn.net/qq_27626333/article/details/53674829', 'no'], //iframe的url，no代表不显示滚动条 end: function(){ //此处用于演示 layer.open({ type: 2, title: '很多时候，我们想最大化看，比如像这个页面。', shadeClose: true, shade: false, maxmin: true, //开启最大化最小化按钮 area: ['893px', '600px'], content: 'http://blog.csdn.net/qq_27626333/article/details/53674829' }); } }); }else if(n==12){ //layer.load(icon, options) - 加载层 var index = layer.load(2, {time: 10*1000}); //又换了种风格，并且设定最长等待10秒 //关闭 //layer.close(index); }else if(n==13){ //loading层 var index = layer.load(1, { shade: [0.1,'#fff'],//0.1透明度的白色背景 time:1000 }); }else if(n==14){ //小tips layer.tips('我是另外一个tips，只不过我长得跟之前那位稍有些不一样。', '.layer_notice', { tips: [1, '#3595CC'], time: 4000 }); }else if(n==15){ //layer.prompt(options, yes) - 输入层 //formType: 1, //输入框类型，支持0（文本）默认1（密码）2（多行文本） //value: '', //初始时的值，默认空字符 //maxlength: 140, //可输入文本的最大长度，默认500 //yes携带value表单值、index索引、elem表单元素 layer.prompt({title: '输入任何口令，并确认', formType: 1}, function(pass, index){ layer.close(index); layer.prompt({title: '随便写点啥，并确认', formType: 2}, function(text, index){ layer.close(index); layer.msg('演示完毕！您的口令：'+ pass +'您最后写下了：'+text); }); }); }else if(n==16){ //layer.tab(options) - tab层 layer.tab({ area: ['600px', '300px'], tab: [{ title: 'TAB1', content: '内容1' }, { title: 'TAB2', content: '内容2' }, { title: 'TAB3', content: '内容3' }] }); }else if(n==17){ //相册层 layer.photos({ photos: '#layer-photos-demo', anim: 5 //0-6的选择，指定弹出图片动画类型，默认随机（请注意，3.0之前的版本用shift参数） }); } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JQuery</tag>
      </tags>
  </entry>
</search>