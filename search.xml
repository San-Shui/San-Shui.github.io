<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CommonJS]]></title>
    <url>%2F2017%2F07%2F04%2FCommonJS%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;CommonJS API定义很多普通应用程序（主要指非浏览器的应用）使用的API，从而填补了这个空白。它的终极目标是提供一个类似Python，Ruby和Java标准库。这样的话，开发者可以使用CommonJS API编写应用程序，然后这些应用可以运行在不同的JavaScript解释器和不同的主机环境中。 在兼容CommonJS的系统中，你可以使用JavaScript开发以下程序： 服务器端JavaScript应用程序 命令行工具 图形界面应用程序 混合应用程序（如，Titanium或Adobe AIR） &emsp;&emsp;2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。这标志”Javascript模块化编程”正式诞生。因为老实说，在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。NodeJS是CommonJS规范的实现，webpack 也是以CommonJS的形式来书写。 1. 概述&emsp;&emsp;Node应用由模块组成，采用CommonJS模块规范。根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。 12345// example.jsvar x = 5;var addX = function (value) &#123; return value + x;&#125;; &emsp;&emsp;上面代码中，变量x和函数addX，是当前文件example.js私有的，其他文件不可见。如果想在多个文件分享变量，必须定义为global对象的属性。 1global.warning = true; &emsp;&emsp;上面代码的warning变量，可以被所有文件读取。当然，这样写法是不推荐的。 &emsp;&emsp;CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。123456var x = 5;var addX = function (value) &#123; return value + x;&#125;;module.exports.x = x;module.exports.addX = addX; &emsp;&emsp;上面代码通过module.exports输出变量x和函数addX。 require方法用于加载模块。1234var example = require('./example.js');console.log(example.x); // 5console.log(example.addX(1)); // 6 CommonJS模块的特点如下。 所有代码都运行在模块作用域，不会污染全局作用域。 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。 模块加载的顺序，按照其在代码中出现的顺序。 &emsp;&emsp;在 Node.js 中，创建一个模块非常简单，如下我们创建一个 ‘main.js’ 文件，代码如下:12var hello = require('./hello');hello.world(); &emsp;&emsp;以上实例中，代码 require(‘./hello’) 引入了当前目录下的hello.js文件（./ 为当前目录，node.js默认后缀为js）。 &emsp;&emsp;Node.js 提供了exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。 &emsp;&emsp;接下来我们就来创建hello.js文件，代码如下：123exports.world = function() &#123; console.log('Hello World');&#125; &emsp;&emsp;在以上示例中，hello.js 通过 exports 对象把 world 作为模块的访问接口，在 main.js 中通过 require(‘./hello’) 加载这个模块，然后就可以直接访问 hello.js 中 exports 对象的成员函数了。 &emsp;&emsp;有时候我们只是想把一个对象封装到模块中，格式如下：123module.exports = function() &#123; // ...&#125; 例如:1234567891011//hello.js function Hello() &#123; var name; this.setName = function(thyName) &#123; name = thyName; &#125;; this.sayHello = function() &#123; console.log('Hello ' + name); &#125;; &#125;; module.exports = Hello; 这样就可以直接获得这个对象了：12345//main.js var Hello = require('./hello'); hello = new Hello(); hello.setName('BYVoid'); hello.sayHello(); &emsp;&emsp;模块接口的唯一变化是使用 module.exports = Hello 代替了exports.world = function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。 2. module对象Node内部提供一个Module构建函数。所有模块都是Module的实例。12345function Module(id, parent) &#123; this.id = id; this.exports = &#123;&#125;; this.parent = parent; // ... 每个模块内部，都有一个module对象，代表当前模块。它有以下属性。 module.id 模块的识别符，通常是带有绝对路径的模块文件名。 module.filename 模块的文件名，带有绝对路径。 module.loaded 返回一个布尔值，表示模块是否已经完成加载。 module.parent 返回一个对象，表示调用该模块的模块。 module.children 返回一个数组，表示该模块要用到的其他模块。 module.exports 表示模块对外输出的值。 下面是一个示例文件，最后一行输出module变量。1234// example.jsvar jquery = require('jquery');exports.$ = jquery;console.log(module); 执行这个文件，命令行会输出如下信息。12345678910111213141516171819&#123; id: '.', exports: &#123; '$': [Function] &#125;, parent: null, filename: '/path/to/example.js', loaded: false, children: [ &#123; id: '/path/to/node_modules/jquery/dist/jquery.js', exports: [Function], parent: [Circular], filename: '/path/to/node_modules/jquery/dist/jquery.js', loaded: true, children: [], paths: [Object] &#125; ], paths: [ '/home/user/deleted/node_modules', '/home/user/node_modules', '/home/node_modules', '/node_modules' ]&#125; &emsp;&emsp;如果在命令行下调用某个模块，比如node something.js，那么module.parent就是undefined。如果是在脚本之中调用，比如require(‘./something.js’)，那么module.parent就是调用它的模块。利用这一点，可以判断当前模块是否为入口脚本。123456789if (!module.parent) &#123; // run with `node something.js` app.listen(8088, function() &#123; console.log('app listening on port 8088'); &#125;)&#125; else &#123; // used with `require('/.something.js')` module.exports = app;&#125; 2.1 module.exports属性&emsp;&emsp;module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。123456var EventEmitter = require('events').EventEmitter;module.exports = new EventEmitter();setTimeout(function() &#123; module.exports.emit('ready');&#125;, 1000); 上面模块会在加载后1秒后，发出ready事件。其他文件监听该事件，可以写成下面这样。1234var a = require('./a');a.on('ready', function() &#123; console.log('module a is ready');&#125;); 2.2 exports变量&emsp;&emsp;为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。1var exports = module.exports; 造成的结果是，在对外输出模块接口时，可以向exports对象添加方法。1234567exports.area = function (r) &#123; return Math.PI * r * r;&#125;;exports.circumference = function (r) &#123; return 2 * Math.PI * r;&#125;;` 注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。1exports = function(x) &#123;console.log(x)&#125;; 上面这样的写法是无效的，因为exports不再指向module.exports了。 下面的写法也是无效的。1234exports.hello = function() &#123; return 'hello';&#125;;module.exports = 'Hello world'; 上面代码中，hello函数是无法对外输出的，因为module.exports被重新赋值了。 这意味着，如果一个模块的对外接口，就是一个单一的值，不能使用exports输出，只能使用module.exports输出。123module.exports = function (x)&#123; console.log(x);&#125;; &emsp;&emsp;如果你觉得，exports与module.exports之间的区别很难分清，一个简单的处理方法，就是放弃使用exports，只使用module.exports。 3. require命令3.1 基本用法&emsp;&emsp;Node使用CommonJS模块规范，内置的require命令用于加载模块文.require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。12345678// example.jsvar invisible = function () &#123; console.log("invisible");&#125;exports.message = "hi";exports.say = function () &#123; console.log(message);&#125; 运行下面的命令，可以输出 exports对象,123456var example = require('./example.js');example// &#123;// message: "hi",// say: [Function]// &#125; &emsp;&emsp;如果模块输出的是一个函数，那就不能定义在exports对象上面，而要定义在module.exports变量上面。1234module.exports = function () &#123; console.log("hello world")&#125;require('./example2.js')() &emsp;&emsp;上面代码中，require命令调用自身，等于是执行module.exports，因此会输出 hello world。 3.2 加载规则&emsp;&emsp;require命令用于加载文件，后缀名默认为.js。123var foo = require('foo');// 等同于var foo = require('foo.js'); 根据参数的不同格式，require命令去不同路径寻找模块文件。 如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文件。比如，require(‘/home/marco/foo.js’)将加载/home/marco/foo.js。 如果参数字符串以“./”开头，则表示加载的是一个位于相对路径（跟当前执行脚本的位置相比）的模块文件。比如，require(‘./circle’)将加载当前脚本同一目录的circle.js。 如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块（位于Node的系统安装目录中），或者一个位于各级node_modules目录的已安装模块（全局安装或局部安装）。 &emsp;&emsp;举例来说，脚本/home/user/projects/foo.js执行了require(‘bar.js’)命令，Node会依次搜索以下文件。 /usr/local/lib/node/bar.js/home/user/projects/node_modules/bar.js/home/user/node_modules/bar.js/home/node_modules/bar.js/node_modules/bar.js&emsp;&emsp;这样设计的目的是，使得不同的模块可以将所依赖的模块本地化。 如果参数字符串不以“./“或”/“开头，而且是一个路径，比如require(‘example-module/path/to/file’)，则将先找到example-module的位置，然后再以它为参数，找到后续路径。 如果指定的模块文件没有发现，Node会尝试为文件名添加.js、.json、.node后，再去搜索。.js件会以文本格式的JavaScript脚本文件解析，.json文件会以JSON格式的文本文件解析，.node文件会以编译后的二进制文件解析。 如果想得到require命令加载的确切文件名，使用require.resolve()方法。 3.3 目录的加载规则&emsp;&emsp;通常，我们会把相关的文件会放在一个目录里面，便于组织。这时，最好为该目录设置一个入口文件，让require方法可以通过这个入口文件，加载整个目录。 &emsp;&emsp;在目录中放置一个package.json文件，并且将入口文件写入main字段。下面是一个例子。123// package.json&#123; "name" : "some-library", "main" : "./lib/some-library.js" &#125; &emsp;&emsp;require发现参数字符串指向一个目录以后，会自动查看该目录的package.json文件，然后加载main字段指定的入口文件。如果package.json文件没有main字段，或者根本就没有package.json文件，则会加载该目录下的index.js文件或index.node文件。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>CommonJS</tag>
        <tag>JavaScript</tag>
        <tag>requirejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AMD]]></title>
    <url>%2F2017%2F06%2F15%2FAMD%2F</url>
    <content type="text"><![CDATA[AMD&emsp;&emsp;本文是源仓库里的”AMD”文档的一份拷贝，放在这里是用来维护历史链接。文中任何与源仓库里的文档不一致之处，以源仓库里的文档为准。 &emsp;&emsp;异步模块定义规范（AMD）制定了定义模块的规则，这样模块和模块的依赖可以被异步加载。这和浏览器的异步加载模块的环境刚好适应（浏览器同步加载模块会导致性能、可用性、调试和跨域访问等问题）。 &emsp;&emsp;此AMD与科技公司AMD 及其制造的AMD处理器无关。 define() 函数&emsp;&emsp;本规范只定义了一个函数 “define”，它是全局变量。函数的描述为： define(id?, dependencies?, factory); id 名字&emsp;&emsp;第一个参数，id，是个字符串。它指的是定义中模块的名字，这个参数是可选的。如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。如果提供了该参数，模块名必须是“顶级”的和绝对的（不允许相对名字）。 模块名的格式 &emsp;&emsp;模块名用来唯一标识定义中模块，它们同样在依赖数组中使用。AMD的模块名规范是CommonJS模块名规范的超集。引用如下： 模块名是由一个或多个单词以正斜杠为分隔符拼接成的字符串 单词须为驼峰形式，或者”.”，”..” 模块名不允许文件扩展名的形式，如”.js” 模块名可以为 “相对的” 或 “顶级的”。如果首字符为”.”或”..”则为”相对的”模块名 顶级的模块名从根命名空间的概念模块解析 相对的模块名从 “require” 书写和调用的模块解析 上文引用的CommonJS模块id属性常被用于JavaScript模块。 相对模块名解析示例： 如果模块 “a/b/c” 请求 “../d”, 则解析为”a/d” 如果模块 “a/b/c” 请求 “./e”, 则解析为”a/b/e” &emsp;&emsp;如果AMD的实现支持加载器插件(Loader-Plugins),则”!”符号用于分隔加载器插件模块名和插件资源名。由于插件资源名可以非常自由地命名，大多数字符都允许在插件资源名使用。 依赖&emsp;&emsp;第二个参数，dependencies，是个定义中模块所依赖模块的数组。依赖模块必须根据模块的工厂方法优先级执行，并且执行的结果应该按照依赖数组中的位置顺序以参数的形式传入（定义中模块的）工厂方法中。 &emsp;&emsp;依赖的模块名如果是相对的，应该解析为相对定义中的模块。换句话来说，相对名解析为相对于模块的名字，并非相对于寻找该模块的名字的路径。 &emsp;&emsp;本规范定义了三种特殊的依赖关键字。如果”require”,”exports”, 或 “module”出现在依赖列表中，参数应该按照CommonJS模块规范自由变量去解析。 &emsp;&emsp;依赖参数是可选的，如果忽略此参数，它应该默认为[“require”, “exports”, “module”]。然而，如果工厂方法的形参个数小于3，加载器会选择以函数指定的参数个数调用工厂方法。 工厂方法&emsp;&emsp;第三个参数，factory，为模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值。 &emsp;&emsp;如果工厂方法返回一个值（对象，函数，或任意强制类型转换为true的值），应该为设置为模块的输出值。 简单的 CommonJS 转换&emsp;&emsp;如果依赖性参数被忽略，模块加载器可以选择扫描工厂方法中的require语句以获得依赖性（字面量形为require(“module-id”)）。第一个参数必须字面量为require从而使此机制正常工作。 &emsp;&emsp;在某些情况下，因为脚本大小的限制或函数不支持toString方法（Opera Mobile是已知的不支持函数的toString方法），模块加载器可以选择扫描不扫描依赖性。 &emsp;&emsp;如果有依赖参数，模块加载器不应该在工厂方法中扫描依赖性。 define.amd 属性&emsp;&emsp;为了清晰的标识全局函数（为浏览器加载script必须的）遵从AMD编程接口，任何全局函数应该有一个”amd”的属性，它的值为一个对象。这样可以防止与现有的定义了define函数但不遵从AMD编程接口的代码相冲突。 &emsp;&emsp;当前，define.amd对象的属性没有包含在本规范中。实现本规范的作者，可以用它通知超出本规范编程接口基本实现的额外能力。 &emsp;&emsp;define.amd的存在表明函数遵循本规范。如果有另外一个版本的编程接口，那么应该定义另外一个属性，如define.amd2，表明实现只遵循该版本的编程接口。 &emsp;&emsp;一个如何定义同一个环境中允许多次加载同一个版本的模块的实现： define.amd = { multiversion: true }; 最简短的定义： define.amd = {}; 一次输出多个模块&emsp;&emsp;在一个脚本中可以使用多次define调用。这些define调用的顺序不应该是重要的。早一些的模块定义中所指定的依赖，可以在同一脚本中晚一些定义。模块加载器负责延迟加载未解决的依赖，直到全部脚本加载完毕，防止没必要的请求。 例子使用 require 和 exports创建一个名为”alpha”的模块，使用了require，exports，和名为”beta”的模块: define("alpha", ["require", "exports", "beta"], function (require, exports, beta) { exports.verb = function() { return beta.verb(); //Or: return require("beta").verb(); } }); 一个返回对象的匿名模块： define(["alpha"], function (alpha) { return { verb: function(){ return alpha.verb() + 2; } }; }); 一个没有依赖性的模块可以直接定义对象： define({ add: function(x, y){ return x + y; } }); 一个使用了简单CommonJS转换的模块定义： define(function (require, exports, module) { var a = require('a'), b = require('b'); exports.action = function () {}; }); 全局变量&emsp;&emsp;本规范保留全局变量”define”以用来实现本规范。包额外信息异步定义编程接口是为将来的CommonJS API保留的。模块加载器不应在此函数添加额外的方法或属性。 &emsp;&emsp;本规范保留全局变量”require”被模块加载器使用。模块加载器可以在合适的情况下自由地使用该全局变量。它可以使用这个变量或添加任何属性以完成模块加载器的特定功能。它同样也可以选择完全不使用”require”。 使用注意&emsp;&emsp;为了使静态分析工具（如build工具）可以正常工作，推荐使用字面上形如的’define(…)’。 与CommonJS的关系&emsp;&emsp;一个关于本API的wiki开始在CommonJS wiki中创建了，作为中转的格式，模块中转。但是为了包含模块定义接口，随着时间而不断改变。在CommonJS列表中关于推荐本API作为模块定义API尚未达成一致。本API被转移到它自己的wiki和讨论组中。 &emsp;&emsp;AMD可以作为CommonJS模块一个中转的版本只要CommonJS没有被用来同步的require调用。使用同步require调用的CommonJS代码可以被转换为使用回调风格的AMD模块加载器。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>requirejs</tag>
        <tag>AMD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown]]></title>
    <url>%2F2017%2F06%2F01%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 [ ] 支持以 PDF 格式导出文稿 [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 [x] 新增 Todo 列表功能 [x] 修复 LaTex 公式渲染问题 [x] 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序获取用户openid]]></title>
    <url>%2F2017%2F01%2F19%2F%E5%8E%9F-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7openid%2F</url>
    <content type="text"><![CDATA[1、wx.login(OBJECT) &nbsp; &nbsp;调用接口获取登录凭证（code）进而换取用户登录态信息，包括用户的唯一标识（openid） 及本次登录的 会话密钥（session_key）。用户数据的加解密通讯需要依赖会话密钥完成。 2、code 换取 session_key ​ &nbsp;这是一个 HTTPS 接口，开发者服务器使用登录凭证 code 获取 session_key 和 openid。其中 session_key 是对用户数据进行加密签名的密钥。为了自身应用安全，session_key 不应该在网络上传输。 接口地址： https://api.weixin.qq.com/sns/jscode2session?appid=APPID&amp;secret=SECRET&amp;js_code=JSCODE&amp;grant_type=authorization_code 详细的介绍请看小程序APIhttps://mp.weixin.qq.com/debug/wxadoc/dev/api/api-login.html#wxloginobject 3、获取用户openid实例 //app.js App({ globalData:{ appid:'1wqas2342dasaqwe2323424ac23qwe',//appid需自己提供，此处的appid我随机编写 secret:'e0dassdadef2424234209bwqqweqw123ccqwa',//secret需自己提供，此处的secret我随机编写 }, onLaunch: function () { var that = this var user=wx.getStorageSync('user') || {}; var userInfo=wx.getStorageSync('userInfo') || {}; if((!user.openid || (user.expires_in || Date.now()) &lt; (Date.now() + 600))&amp;&amp;(!userInfo.nickName)){ wx.login({ success: function(res){ if(res.code) { wx.getUserInfo({ success: function (res) { var objz={}; objz.avatarUrl=res.userInfo.avatarUrl; objz.nickName=res.userInfo.nickName; //console.log(objz); wx.setStorageSync('userInfo', objz);//存储userInfo } }); var d=that.globalData;//这里存储了appid、secret、token串 var l='https://api.weixin.qq.com/sns/jscode2session?appid='+d.appid+'&amp;secret='+d.secret+'&amp;js_code='+res.code+'&amp;grant_type=authorization_code'; wx.request({ url: l, data: {}, method: 'GET', // OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT // header: {}, // 设置请求的 header success: function(res){ var obj={}; obj.openid=res.data.openid; obj.expires_in=Date.now()+res.data.expires_in; //console.log(obj); wx.setStorageSync('user', obj);//存储openid } }); }else { console.log('获取用户登录态失败！' + res.errMsg) } } }); } }, })]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用nginx做node.js的反向代理]]></title>
    <url>%2F2017%2F01%2F04%2F%E5%8E%9F-%E7%94%A8nginx%E5%81%9Anode-js%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[1、安装nginx （1）、从nginx官网下载相应的安装包 &nbsp; &nbsp;下载地址：http://nginx.org。建议下稳定版 （2)、启动 解压至D:\Download\nginx-1.10.2，双击nginx.exe运行(或者通过控制台nginx -c conf\nginx.conf)，默认使用80端口，日志见文件夹D:\Download\nginx-1.10.2\logs （3)、使用 此时 直接在浏览器地址栏输入：http://localhost 便能看到 欢迎页面，说明你虚拟主机已经搭建好了 （4）、关闭 &nbsp; &nbsp;nginx -s stop&nbsp; （5）、配置Nginx &nbsp; &nbsp;进入conf 目录，在该目录下创建include 文件。进入 conf/include 目录，创建 nginx.node.conf 文件，在里面输入如下代码： upstream nodejs { server 127.0.0.1:3000; keepalive 64;} server { listen 80; server_name www.zmnode.com zmnode.com; location / { proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Nginx-Proxy true; proxy_set_header Connection &quot;&quot;; proxy_pass http://nodejs; } }进入conf ，打开nginx.conf, 在http 里面添加 include ./include/*。重启nginx , 输入 nginx -c conf/nginx.conf 在浏览器输入zmnode.com]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js中mysql数据库连接池]]></title>
    <url>%2F2017%2F01%2F04%2F%E5%8E%9F-node-js%E4%B8%ADmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[&nbsp; 在MySQL模块中，使用createPool方法创建连接池，在建立了连接池之后，可以直接使用连接池对象的getConnection方法从连接池中获取一个连接，如果连接池中没有可用连接，将隐式的建立一个数据库连接。 &nbsp; connection.release() 当一个连接不需要使用时，使用该方法将其归还到连接池中 &nbsp; connection.destroy() 当一个连接不需要使用且需要从连接池中移除时，可以使用该方法 &nbsp; pool.end() 当一个连接池不需要使用时，可以使用该方法关闭连接池 注意：可以使用createPool方法的属性connectionLimit设置连接池中的最大连接数，默认为10&nbsp;&nbsp; 1、安装node的mysql模块 npm install -g mysql &nbsp; 2、建立一个类库，就叫mysql.js吧，然后内容如下: &nbsp; var mysql=require(&quot;mysql&quot;);var pool = mysql.createPool({ host: ‘localhost’, user: ‘user’, password: ‘password’, database: ‘database’, port: 3306});var query=function(sql,callback){ pool.getConnection(function(err,conn){ if(err){ callback(err,null,null); }else{ conn.query(sql,function(err, result){ if(err){ &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; console.log(‘查询数据失败’); &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }else{ &nbsp;&nbsp; //释放连接 conn.release(); //事件驱动回调 callback(result);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; }); } }); }; module.exports=query; &nbsp; 3，在js类使用如下 &nbsp; var query=require(&quot;./lib/mysql.js&quot;); query(&quot;select 1 from 1&quot;,function(err,result){ //do something }); &nbsp;]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[supervisor与pm2]]></title>
    <url>%2F2017%2F01%2F04%2F%E5%8E%9F-supervisor%E4%B8%8Epm2%2F</url>
    <content type="text"><![CDATA[1、supervisor &nbsp; 在开发过程中，每次修改代码保存后，我们都需要手动重启程序，才能查看改动的效果。使用 supervisor 可以解决这个繁琐的问题，全局安装 supervisor。这里注意一点的就是，supervisor必须安装到全局，如果你不安装到全局，错误命令会提示你安装到全局。 &nbsp; npm install -g supervisor 运行 supervisor –harmony index 启动程序，如下所示： 安装完以后就可以用supervisor 来启动服务了。 supervisor www 启动完全是这个样子 输入网址启动请求如下图： 修改www文件然后请求如下图： 2、pm2 &nbsp; 当我们的项目要部署到线上服务器时，不能单纯的靠 node index 或者 supervisor index 来启动了，因为我们断掉 SSH 连接后服务就终止了，这时我们就需要像 pm2 或者 forever 这样的进程管理器了。pm2 是 Node.js 下的生产环境进程管理工具，就是我们常说的进程守护工具，可以用来在生产环境中进行自动重启、日志记录、错误预警等等。pm2官方文档：http://pm2.keymetrics.io/docs/usage/quick-start/ 以 pm2 为例，全局安装 pm2： &nbsp;首先需要安装pm2： &nbsp; &nbsp;npm install -g pm2 &nbsp;&nbsp; &nbsp;运行： &nbsp; &nbsp;pm2 start www.js 或者修改 package.json中的start命令： &quot;scripts&quot;: { &quot;start&quot;: &quot;pm2 start ./bin/www&quot; } 然后运行 npm start 通过 pm2 启动程序，如下图所示 ： pm2 常用命令: &nbsp;安装：npm install -g pm2 &nbsp;启动程序：pm2 start &lt;app_name|id|all&gt; &nbsp;列举进程：pm2 list &nbsp;退出程序：pm2 stop &lt;app_name|id|all&gt; &nbsp;重起应用：pm2 restart &nbsp;程序信息：pm2 describe id|all &nbsp;监控：pm2 monit &nbsp;实时集中log处理: pm2 logs &nbsp;API:pm2 web (端口：9615 ) 参考链接： &nbsp;&nbsp;nodejs高大上的部署方式-PM2 &nbsp; &nbsp; &nbsp; &nbsp;使用高大上的pm2代替forever部署nodejs项目 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;]]></content>
      <categories>
        <category>supervisor与pm2</category>
      </categories>
      <tags>
        <tag>supervisor与pm2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express 快速创建一个应用的骨架]]></title>
    <url>%2F2016%2F12%2F30%2F%E5%8E%9F-express-%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%9A%84%E9%AA%A8%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[&nbsp; express 4.x以后将express命令独立到 express-generator包中，所以想使用express初始化项目目录，必须安装express-generator -h 选项可以列出所有可用的命令行选项： 例如，下面的示例就是在当前工作目录下创建一个命名为 myApp 的应用。 然后安装所有依赖包： 启动这个应用Windows 平台使用如下命令： 然后在浏览器中打开 http://localhost:3000/ 网址就可以看到这个应用了。 通过 Express 应用生成器创建的应用一般都有如下目录结构：]]></content>
      <categories>
        <category>express</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js Express 框架]]></title>
    <url>%2F2016%2F12%2F30%2F%E5%8E%9F-Node-js-Express-%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[&nbsp; Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。使用 Express 可以快速地搭建一个完整功能的网站。Express 框架核心特性：（1）、可以设置中间件来响应 HTTP 请求。（2）、定义了路由表用于执行不同的 HTTP 请求动作。（3）、可以通过向模板传递参数来动态渲染 HTML 页面。 已经在电脑D:\NodeProject\express目录下安装了express、body-parser、cookie-parser、express-generator、multer、mysql模块 1、请求和响应 Express 应用使用回调函数的参数： request 和 response 对象来处理请求和响应的数据。 以下实例中我们引入了express 模块，并在客户端发起请求后，响应字符串。 var express = require(‘../express/node_modules/express’);var app = express();app.get(‘/‘, function (req, res) {&nbsp; &nbsp;res.send(‘大家好！我是山水子农，正在学习express框架！’);})var server = app.listen(8081, function () {&nbsp; var host = server.address().address&nbsp; var port = server.address().port&nbsp; console.log(&quot;应用实例，访问地址为 http://%s:%s&amp;quot;, host, port) }) 执行以上代码： Request 对象 - request 对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP 头部等属性。常见属性有： （1）、req.app：当callback为外部文件时，用req.app访问express的实例 （2）、req.baseUrl：获取路由当前安装的URL路径 （3）、req.body / req.cookies：获得「请求主体」/ Cookies （4）、req.fresh / req.stale：判断请求是否还「新鲜」 （5）、req.hostname / req.ip：获取主机名和IP地址 （6）、req.originalUrl：获取原始请求URL （7）、req.params：获取路由的parameters （8）、req.path：获取请求路径 （9）、req.protocol：获取协议类型 （10）、req.query：获取URL的查询参数串 （11）、req.route：获取当前匹配的路由 （12）、req.subdomains：获取子域名 （13）、req.accpets（）：检查请求的Accept头的请求类型 （14）、req.acceptsCharsets / req.acceptsEncodings / req.acceptsLanguages （15）、req.get（）：获取指定的HTTP请求头 （16）、req.is（）：判断请求头Content-Type的MIME类型 Response 对象 - response 对象表示 HTTP 响应，即在接收到请求时向客户端发送的 HTTP 响应数据。常见属性有： （1）、res.app：同req.app一样 （2）、res.append（）：追加指定HTTP头 （3）、res.set（）在res.append（）后将重置之前设置的头 （4）、res.cookie（name，value [，option]）：设置Cookie （5）、opition: domain / expires / httpOnly / maxAge / path / secure / signed （6）、res.clearCookie（）：清除Cookie （7）、res.download（）：传送指定路径的文件 （8）、res.get（）：返回指定的HTTP头 （9）、res.json（）：传送JSON响应 （10）、res.jsonp（）：传送JSONP响应 （11）、res.location（）：只设置响应的Location HTTP头，不设置状态码或者close response （12）、res.redirect（）：设置响应的Location HTTP头，并且设置状态码302 （13）、res.send（）：传送HTTP响应 （14）、res.sendFile（path [，options] [，fn]）：传送指定路径的文件 -会自动根据文件extension设定Content-Type （15）、res.set（）：设置HTTP头，传入object可以一次设置多个头 （16）、res.status（）：设置HTTP状态码 （17）、res.type（）：设置Content-Type的MIME类型 2、路由 &nbsp; 我们已经了解了 HTTP 请求的基本应用，而路由决定了由谁(指定脚本)去响应客户端请求。在HTTP请求中，我们可以通过路由提取出请求的URL以及GET/POST参数。接下来我们扩展上例，添加一些功能来处理更多类型的 HTTP 请求。 var express = require(‘../express/node_modules/express’);var app = express();// 主页输出 &quot;Hello World&quot;app.get(‘/‘, function (req, res) { console.log(&quot;主页 GET 请求&quot;); res.send(‘Hello GET’);})// POST 请求app.post(‘/‘, function (req, res) { console.log(&quot;主页 POST 请求&quot;); res.send(‘Hello POST’);})// /del_user 页面响应app.get(‘/del_user’, function (req, res) { console.log(&quot;/del_user 响应 DELETE 请求&quot;); res.send(‘删除页面’);})// /list_user 页面 GET 请求app.get(‘/list_user’, function (req, res) { console.log(&quot;/list_user GET 请求&quot;); res.send(‘用户列表页面’);})// 对页面 abcd, abxcd, ab123cd, 等响应 GET 请求app.get(‘/abcd’, function(req, res) { console.log(&quot;/abcd GET 请求&quot;); res.send(‘正则匹配’);})var server = app.listen(8081, function () { var host = server.address().address var port = server.address().port console.log(&quot;应用实例，访问地址为 http://%s:%s&amp;quot;, host, port)}) 3、静态文件 &nbsp; Express 提供了内置的中间件 express.static 来设置静态文件如：图片， CSS, JavaScript 等。你可以使用 express.static 中间件来设置静态文件路径。例如，如果你将图片， CSS, JavaScript 文件放在 public 目录下，你可以这么写： app.use(express.static(‘public’));添加处理静态文件的代码如下所示： var express = require(‘../express/node_modules/express’);var app = express();app.use(express.static(‘public’));app.get(‘/‘, function (req, res) { res.send(‘大家好！我是山水子农，正在学习express的静态文件’);})var server = app.listen(8088, function () { var host = server.address().address var port = server.address().port console.log(&quot;应用实例，访问地址为 http://%s:%s&amp;quot;, host, port) }) 4、GET 方法 &nbsp; 以下实例演示了在表单中通过 GET 方法提交两个参数，我们可以使用 server.js 文件内的 process_get 路由器来处理输入， index.html 文件代码如下： &lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://127.0.0.1:8081/process_get&amp;quot; method=&quot;GET&quot;&gt;First Name: &lt;input type=&quot;text&quot; name=&quot;first_name&quot;&gt; &lt;br&gt;&lt;br&gt;Last Name: &lt;input type=&quot;text&quot; name=&quot;last_name&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;server.js 文件代码如下: var express = require('../express/node_modules/express'); var app = express(); //设置静态文件 app.use(express.static('public')); app.get('/index.htm', function (req, res) { //传送指定路径的文件 //__dirname 表示当前执行脚本所在的目录。 //__filename 表示当前正在执行的脚本的文件名。 &nbsp; &nbsp;res.sendFile( __dirname + &quot;/&quot; + &quot;index.html&quot; );//index.html路径D:\NodeProject\ExpressDemo\public\index.html }) app.get('/process_get', function (req, res) { &nbsp; &nbsp;// 输出 JSON 格式 &nbsp; &nbsp;response = { &nbsp; &nbsp; &nbsp; &nbsp;first_name:req.query.first_name,//req.query获取URL的查询参数串 &nbsp; &nbsp; &nbsp; &nbsp;last_name:req.query.last_name &nbsp; &nbsp;}; &nbsp; &nbsp;console.log(response); &nbsp; &nbsp;res.end(JSON.stringify(response));//传送HTTP响应 }) var server = app.listen(8081, function () { &nbsp; //server.address()操作系统返回绑定的地址，协议族名和服务器端口。 &nbsp; var host = server.address().address &nbsp; var port = server.address().port &nbsp; console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port) }) 执行以上代码： 5、POST 方法 &nbsp; 以下实例演示了在表单中通过 POST 方法提交两个参数，我们可以使用 serverPost.js 文件内的 process_post 路由器来处理输入。indexPost.htm 文件代码修改如下： &lt;html&gt;&lt;body&gt;&lt;form action=&quot;http://127.0.0.1:8081/process_post&amp;quot; method=&quot;POST&quot;&gt;First Name: &lt;input type=&quot;text&quot; name=&quot;first_name&quot;&gt; &lt;br&gt;&lt;br&gt;Last Name: &lt;input type=&quot;text&quot; name=&quot;last_name&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;serverPost.js 文件代码修改如下 var express = require(‘../express/node_modules/express’);var app = express();var bodyParser = require(‘../express/node_modules/body-parser’);// 创建 application/x-www-form-urlencoded 编码解析var urlencodedParser = bodyParser.urlencoded({ extended: false })app.use(express.static(‘public’));app.get(‘/indexPost.htm’, function (req, res) { res.sendFile( __dirname + &quot;/&quot; + &quot;indexPost.htm&quot; );})app.post(‘/process_post’, urlencodedParser, function (req, res) { // 输出 JSON 格式 response = { first_name:req.body.first_name, last_name:req.body.last_name }; console.log(response); res.end(JSON.stringify(response));})var server = app.listen(8081, function () { var host = server.address().address var port = server.address().port console.log(&quot;应用实例，访问地址为 http://%s:%s&amp;quot;, host, port) }) 执行以上代码：]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node.js</tag>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js Web 模块]]></title>
    <url>%2F2016%2F12%2F30%2F%E5%8E%9F-Node-js-Web-%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[1、使用 Node 创建 Web 服务器 &nbsp; Node.js 提供了 http 模块，http 模块主要用于搭建 HTTP 服务端和客户端，使用 HTTP 服务器或客户端功能必须调用 http 模块，代码如下： var http = require(‘http’);以下是演示一个最基本的 HTTP 服务器架构(使用8081端口)，创建 server.js 文件，代码如下所示： var http = require('http'); var fs = require('fs'); var url = require('url'); // 创建服务器 http.createServer( function (request, response) { // 解析请求，包括文件名 var pathname = url.parse(request.url).pathname; // 输出请求的文件名 console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;); // 从文件系统中读取请求的文件内容 fs.readFile(pathname.substr(1), function (err, data) { if (err) { console.log(err); // HTTP 状态码: 404 : NOT FOUND // Content Type: text/plain response.writeHead(404, {'Content-Type': 'text/html'}); }else{ // HTTP 状态码: 200 : OK // Content Type: text/plain response.writeHead(200, {'Content-Type': 'text/html'}); // 响应文件内容 response.write(data.toString()); } // 发送响应数据 response.end(); }); }).listen(8081); // 控制台会输出以下信息 console.log('Server running at http://127.0.0.1:8081/');接下来我们在该目录下创建一个 index.htm 文件，代码如下： &lt;html&gt; &lt;head&gt; &lt;title&gt;Sample Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 执行 server.js 文件： 2、使用 Node 创建 Web 客户端 Node 创建 Web 客户端需要引入 http 模块，创建 client.js 文件，代码如下所示： var http = require(‘http’);// 用于请求的选项var options = { host: ‘localhost’, port: ‘8081’, path: ‘/index.htm’};// 处理响应的回调函数var callback = function(response){ // 不断更新数据 var body = ‘’; response.on(‘data’, function(data) { body += data; }); response.on(‘end’, function() { // 数据接收完成 console.log(body); });}// 向服务端发送请求var req = http.request(options, callback);req.end();新开一个终端，执行 client.js 文件，输出结果如下：]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js Path 模块]]></title>
    <url>%2F2016%2F12%2F30%2F%E5%8E%9F-Node-js-Path-%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[Node.js path 模块提供了一些用于处理文件路径的小工具，我们可以通过以下方式引入该模块： var path = require(&quot;path&quot;) 下面是path模块的实例： var path = require(&quot;path&quot;);// 格式化路径console.log(‘normalization : ‘ + path.normalize(‘/shanshuizinong/shanshuizinong1//2slashes/1slash/tab/..’));// 连接路径console.log(‘joint path : ‘ + path.join(‘/shanshuizinong’, ‘shanshuizinong1’, ‘2slashes/1slash’, ‘tab’, ‘..’));// 格式化路径去掉&quot;..&quot;console.log(‘normalization : ‘ + path.normalize(‘/shanshuizinong/shanshuizinong1//2slashes/1slash/tab’));// 连接路径去掉&quot;..&quot;console.log(‘joint path : ‘ + path.join(‘/shanshuizinong’, ‘shanshuizinong1’, ‘2slashes/1slash’, ‘tab’ ));// 转换为绝对路径var resolve=path.resolve(‘main.js’);console.log(‘resolve : ‘ + resolve);//判断是否为绝对路径console.log(‘isAbsolute :’+path.isAbsolute(resolve));//将相对路径转化为绝对路径console.log(‘relative :’+path.relative(&quot;main.js&quot;,&quot;D:\node&quot;));//返回路径中的最后一部分。console.log(&quot;basename ：&quot;+path.basename(‘D:\NodeProject\path\path.js’));// 路径中文件的后缀名console.log(‘extname : ‘ + path.extname(‘main.js’)); 1、路径解析，得到规范化的路径&#26684;式 对window系统，目录分隔为’\’, 对于UNIX系统，分隔符为’/‘，针对’..’返回上一级；/与\都被统一转换 path.normalize(p); console.log(‘normalization : ‘ + path.normalize(‘/shanshuizinong/shanshuizinong1//2slashes/1slash/tab/..’));2、路径结合、合并，路径最后不会带目录分隔符 path.join([path1],[path2]..[pathn]); console.log(‘joint path : ‘ + path.join(‘/shanshuizinong’, ‘shanshuizinong1’, ‘2slashes/1slash’, ‘tab’, ‘..’));3、获取绝对路径 以应用程序为起点，根据参数字符串解析出一个绝对路径 path.resolve(path1, [path2]..[pathn]); path 必须至少一个路径字符串&#20540; [pathn]可选路径字符串 var myPath = path.resolve(‘path1’, ‘path2’, ‘a/b\c/‘);console.log(myPath);//E:\workspace\NodeJS\path1\path2\a\b\c4、获取相对路径 获取两路径之间的相对关系 path.relative(from, to); from 当前路径，并且方法返回&#20540;是基于from指定到to的相对路径 to 到哪路径， console.log(‘relative :’+path.relative(&quot;main.js&quot;,&quot;D:\node&quot;));5、path.dirname(p) 获取路径中目录名 var myPath = path.dirname(__dirname + ‘/test/util you.mp3’);console.log(myPath);6、path.basename(path, [ext]) 获取路径中文件名,后缀是可选的，如果加，请使用’.ext’方式来匹配，则返回&#20540;中不包括后缀名； var myPath = path.basename(__dirname + ‘/test/util you.mp3’, ‘.mp3’);console.log(myPath);7、path.extname(path) 获取路径中的扩展名，如果没有’.’，则返回空 console.log(‘extname : ‘ &#43; path.extname(‘main.js’));]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js GET/POST请求]]></title>
    <url>%2F2016%2F12%2F30%2F%E5%8E%9F-Node-js-GET-POST%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[1、获取GET请求内容 &nbsp; 由于GET请求直接被嵌入在路径中，URL是完整的请求路径，包括了?后面的部分，因此你可以手动解析后面的内容作为GET请求的参数。node.js中url模块中的parse函数提供了这个功能。我们可以使用 url.parse 方法来解析 URL 中的参数，代码如下： var http = require(‘http’);var url = require(‘url’);http.createServer(function(req, res){ res.writeHead(200, {‘Content-Type’: ‘text/plain’}); // 解析 url 参数 var params = url.parse(req.url, true).query; res.write(&quot;用户名：&quot; + params.username); res.write(&quot;\n&quot;); res.write(&quot;密 码：&quot; + params.password); res.end(); }).listen(80); ** ** 2、获取 POST 请求内容 &nbsp; &nbsp;POST 请求的内容全部的都在请求体中，http.ServerRequest 并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。比如上传文件，而很多时候我们可能并不需要理会请求体的内容，恶意的POST请求会大大消耗服务器的资源，所有node.js 默认是不会解析请求体的，当你需要的时候，需要手动来做。以下实例表单通过 POST 提交并输出数据： var http = require(‘http’);var querystring = require(‘querystring’); var postHTML = ‘&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程 Node.js 实例&lt;/title&gt;&lt;/head&gt;’ + ‘&lt;body&gt;’ + ‘&lt;form method=&quot;post&quot;&gt;’ + ‘网站名： &lt;input name=&quot;name&quot;&gt;&lt;br&gt;’ + ‘网站 URL： &lt;input name=&quot;url&quot;&gt;&lt;br&gt;’ + ‘&lt;input type=&quot;submit&quot;&gt;’ + ‘&lt;/form&gt;’ + ‘&lt;/body&gt;&lt;/html&gt;’; http.createServer(function (req, res) { var body = &quot;&quot;; // 通过req的data事件监听函数，每当接受到请求体的数据，就累加到body变量中 req.on(‘data’, function (chunk) { body += chunk; }); // 在end事件触发后，通过querystring.parse将body解析为真正的POST请求格式，然后向客户端返回。 req.on(‘end’, function () { // 解析参数 body = querystring.parse(body); // 设置响应头部信息及编码 res.writeHead(200, {‘Content-Type’: ‘text/html; charset=utf8’}); if(body.name &amp;amp;&amp;amp; body.url) { // 输出提交的数据 res.write(&amp;quot;用户名：&amp;quot; + body.name); res.write(&amp;quot;&amp;lt;br&amp;gt;&amp;quot;); res.write(&amp;quot;密 码：&amp;quot; + body.url); } else { // 输出表单 res.write(postHTML); } res.end(); });}).listen(80);]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node.js</tag>
        <tag>GET/POST请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js 路由]]></title>
    <url>%2F2016%2F12%2F30%2F%E5%8E%9F-Node-js-%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[&nbsp; &nbsp; 我们要为路由提供请求的URL和其他需要的GET及POST参数，随后路由需要根据这些数据来执行相应的代码。因此，我们需要查看HTTP请求，从中提取出请求的URL以及GET/POST参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实&#20540;得探讨，但这里暂定其为我们的HTTP服务器的功能。我们需要的所有数据都会包含在request对象中，该对象作为onRequest()回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，它们分别是url和querystring模块。 现在我们可以来编写路由了，建立一个名为 router.js 的文件，添加以下内容： function route(pathname) { console.log(&quot;About to route a request for &quot; + pathname);}exports.route = route;如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。 &nbsp; &nbsp; &nbsp;我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块。 首先，我们来扩展一下服务器的start()函数，以便将路由函数作为参数传递过去，server.js 文件代码如下 var http = require(&quot;http&quot;);var url = require(&quot;url&quot;);function start(route) { function onRequest(request, response) { var pathname = url.parse(request.url).pathname; console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;); route(pathname); response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;}); response.write(&quot;大家好！我是山水子农，正在学习Node.js&quot;); response.end(); } http.createServer(onRequest).listen(8888); console.log(&quot;Server has started.&quot;);}exports.start = start;同时，我们会相应扩展index.js，使得路由函数可以被注入到服务器中： var server = require(&quot;./server&quot;);var router = require(&quot;./router&quot;);server.start(router.route);在这里，我们传递的函数依旧什么也没做。如果现在启动应用（node index.js，始终记得这个命令行），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由： 浏览器访问 http://127.0.0.1:8888/?username=sanshuizinong&amp;password=123456，输出结果如下：]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Html的空格显示]]></title>
    <url>%2F2016%2F12%2F18%2F%E8%BD%AC-Html%E7%9A%84%E7%A9%BA%E6%A0%BC%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[一、使用全角空&#26684; 全角空&#26684;被解释为汉字，所以不会被被解释为HTML分隔符，可以按照实际的空&#26684;数显示。 二、使用空&#26684;的替代符号 替代符号就是在需要显示空&#26684;的地方加入替代符号，这些符号会被浏览器解释为空&#26684;显示。 空&#26684;的替代符号有以下几种： 名称编号描述&amp;nbsp;&amp;#160;不断行的空白（1个字符宽度）&amp;ensp;&amp;#8194;半个空白（1个字符宽度）&amp;emsp;&amp;#8195;一个空白（2个字符宽度）&amp;thinsp;&amp;#8201;窄空白（小于1个字符宽度） 可以用名称或编号作为空&#26684;的替代符号，名称必须小写，末尾的“;”不能省略。 如： 欢&amp;nbsp;&amp;nbsp;迎&amp;nbsp;&amp;nbsp;光&amp;nbsp;&amp;nbsp;临！ 显示效果为：欢&nbsp; 迎&nbsp; 光&nbsp; 临！ 三、使用CSS的 white-space 属性 CSS的white-space属性用于设置文本中空&#26684;的处理方式，当white-space属性取&#20540;为pre时，浏览器会保留文本中的空&#26684;和换行，这样你就可以直接在文本中使用空&#26684;和回车了。 这种方法特别适合于在网页中显示程序代码。比如：显示一段C程序代码。 &lt;div style=&quot;white-space:pre&quot;&gt;int sub(int x,int y){&nbsp;&nbsp;&nbsp; int z;&nbsp;&nbsp;&nbsp; if( x&amp;gt;y )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z = x-y;&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z = y-x;&nbsp;&nbsp;&nbsp; return z;}&lt;/div&gt; 显示效果为： int sub(int x,int y){&nbsp;&nbsp;&nbsp; int z;&nbsp;&nbsp;&nbsp; if( x&gt;y )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z = x-y;&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z = y-x;&nbsp;&nbsp;&nbsp; return z;} 使用HTML的&lt;pre&gt;标签也可以达到类&#20284;的效果，但&lt;pre&gt;标签有一些不太好的特性，不如使用CSS的white-space属性更方便。 四、使用CSS的 letter-spacing 属性 CSS的letter-spacing属性用于设置文本中字符之间的间隔，它的取&#20540;可以是一个带单位的长度&#20540;，浏览器会在字和字之间设置指定长度的空白。比如： &lt;div style=&quot;letter-spacing:30px&quot;&gt;欢迎光临！&lt;/div&gt; 显示效果为： 欢迎光临！ 注意，如果文本中有英文单词，则空白会加在字母之间，而不是单词之间。 五、使用CSS的 word-spacing 属性 CSS的word-spacing属性用于设置文本中单词之间的间隔，它的取&#20540;可以是一个带单位的长度&#20540;，浏览器会在单词和单词之间设置指定长度的空白。比如： &lt;div style=&quot;word-spacing:30px&quot;&gt;Happy new year!&lt;/div&gt; 显示效果为： Happy new year! 注意，HTML是以空&#26684;来区分单词的，它会把单词间的空白按指定长度显示。 六、使用CSS的 text-indent 属性 CSS的text-indent属性用于设置首行缩进，它的取&#20540;可以是一个带单位的长度&#20540;，浏览器会在段落的首行开始处设置指定长度的空白。比如： &lt;div style=&quot;text-indent:2em&quot;&gt;欢迎光临！&lt;/div&gt; 显示效果为： 欢迎光临！ 说明：em 是一个相对长度单位，2em 表示要缩进两个字的距离。]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[checkbox利用JQuer中 attr设置状态只有第一次有用]]></title>
    <url>%2F2016%2F12%2F18%2F%E5%8E%9F-checkbox%E5%88%A9%E7%94%A8JQuer%E4%B8%AD-attr-39-checked-39-true-%E8%AE%BE%E7%BD%AE%E7%8A%B6%E6%80%81%E5%8F%AA%E6%9C%89%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%9C%89%E7%94%A8%2F</url>
    <content type="text"><![CDATA[&nbsp; 在JQuery中可以使用attr()来访问对象的属性，但是在某些时候，比如访问input的disabled属性的时候，会有些问题。在有的浏览器中，只要写了disabled属性就可以，有的则要写：disabled=&quot;disabled&quot;。所以JQuery提供了新的方法prop()来获取这些属性，使用prop()的时候，返回&#20540;是标准属性：true/false，不会回返“disabled”或者“”。那么，那些属性应该使用attr()访问，哪些应该用prop()访问呢？ 第一个原则：只添加属性名称该属性就会生效的应该使用prop()； 第二个原则：只存在true/false的属性应该使用prop()。 像如果是设置disabled或者checked这些属性，应该使用prop()方法，而不是使用attr()方法。 &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;复选框应用&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.10.2.min.js&quot; &gt;&lt;/script&gt; &lt;style&gt; .checkbox{ border: 1px solid #A9A9A9; margin: 10px auto; padding: 10px 10px; } &lt;/style&gt; &lt;script&gt; $(function(){ //全选 $(&quot;#CheckedAll&quot;).click(function(){ //$(&quot;[name=items]:checkbox&quot;).attr(‘checked’,true);//只有第一次生效 $(&quot;[name=items]:checkbox&quot;).prop(‘checked’,true);//只有第一次生效 }); //全不选 $(&quot;#CheckedNo&quot;).click(function(){ //$(&quot;[name=items]:checkbox&quot;).attr(‘checked’,false);//只有第一次生效 $(&quot;[name=items]:checkbox&quot;).prop(‘checked’,false); }); //反选 $(&quot;#CheckedRev&quot;).click(function(){ $(&quot;[name=items]:checkbox&quot;).each(function(){ this.checked=!this.checked; }) }); //提交 $(&quot;#send&quot;).click(function(){ var str=&quot;你选中的是：\r\n&quot;; $(&quot;[name=items]:checked&quot;).each(function(){ str+=$(this).val()+&quot;\r\n&quot;; }) alert(str); }); //全选/全不选 $(&quot;#CheckedAN&quot;).click(function(){ $(&quot;[name=items]:checkbox&quot;).prop(&quot;checked&quot;,this.checked); }) //当复选框取消某一个选项的选中状态是时，全选/全不选需要取消选中状态 $(&quot;[name=items]:checkbox&quot;).click(function(){ var tmp=$(&quot;[name=items]:checkbox&quot;); $(&quot;#CheckedAN&quot;).prop(&quot;checked&quot;,tmp.length==tmp.filter(&quot;:checked&quot;).length); }) }) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot; id=&quot;regForm&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;复选框应用&lt;/legend&gt; &lt;div class=&quot;checkbox&quot;&gt; 你爱好的运动是？ &lt;input type=&quot;checkbox&quot; id=&quot;CheckedAN&quot; value=&quot;全选/全不选&quot;/&gt;全选/全不选 &lt;br /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;足球&quot;/&gt;足球 &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;篮球&quot;/&gt;篮球 &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;羽毛球&quot; /&gt;羽毛球 &lt;input type=&quot;checkbox&quot; name=&quot;items&quot; value=&quot;乒乓球&quot; /&gt;乒乓球 &lt;br /&gt; &lt;input type=&quot;button&quot; id=&quot;CheckedAll&quot; value=&quot;全选&quot;/&gt; &lt;input type=&quot;button&quot; id=&quot;CheckedNo&quot; value=&quot;全不选&quot;/&gt; &lt;input type=&quot;button&quot; id=&quot;CheckedRev&quot; value=&quot;反选&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;send&quot; value=&quot;提交&quot; /&gt; &lt;/div&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JQuery</tag>
        <tag>checkbox</tag>
        <tag>attr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[layer.js]]></title>
    <url>%2F2016%2F12%2F15%2F%E5%8E%9F-layer-js%2F</url>
    <content type="text"><![CDATA[1、、基础参数 &nbsp; 我们提到的基础参数主要指调用方法时用到的配置项，如：layer.open({content: ‘’})layer.msg(‘’, {time: 3})等，其中的content和time即是基础参数，以键&#20540;形式存在，基础参数可合理应用于任何层类型中，您不需要所有都去配置，大多数都是可选的。而其中的layer.open、layer.msg就是内置方法。注意，从2.3开始，无需通过layer.config来加载拓展模块 （1）、type - 基本层类型 &nbsp; 类型：Number，默认：0 &nbsp; layer提供了5种层类型。可传入的&#20540;有：0（信息框，默认）1（页面层）2（iframe层）3（加载层）4（tips层）。若你采用layer.open({type: 1})方式调用，则type为必填项（信息框除外） （2）、title - 标题 &nbsp; 类型：String/Array/Boolean，默认：’信息’ &nbsp; title支持三种类型的&#20540;，若你传入的是普通的字符串，如title :’我是标题’，那么只会改变标题文本；若你还需要自定义标题区域样式，那么你可以title: [‘文本’, ‘font-size:18px;’]，数组第二项可以写任意css样式；如果你不想显示标题栏，你可以title: false （3）、content - 内容 类型：String/DOM/Array，默认：’’ content可传入的&#20540;是灵活多变的，不仅可以传入普通的html内容，还可以指定DOM，更可以随着type的不同而不同。譬如： /!* 如果是页面层 */ layer.open({ type: 1, content: '传入任意的文本或html' //这里content是一个普通的String }); layer.open({ type: 1, content: $('#id') //这里content是一个DOM }); //Ajax获取 $.post('url', {}, function(str){ layer.open({ type: 1, content: str //注意，如果str是object，那么需要字符拼接。 }); }); /!* 如果是iframe层 */ layer.open({ type: 2, content: 'http://sentsin.com' //这里content是一个URL，如果你不想让iframe出现滚动条，你还可以content: ['http://sentsin.com', 'no'] }); /!* 如果是用layer.open执行tips层 */ layer.open({ type: 4, content: ['内容', '#id'] //数组第二项即吸附元素选择器或者DOM }); **（4）、skin - 样式类名** &nbsp; 类型：String，默认：'' &nbsp; skin不仅允许你传入layer内置的样式class名，还可以传入您自定义的class名。这是一个很好的切入点，意味着你可以借助skin轻松完成不同的风&#26684;定制。目前layer内置的skin有：layui-layer-lan、layui-layer-molv，未来我们还会选择性地内置更多，但更推荐您自己来定义。 **（5）、area - 宽高** &nbsp; 类型：String/Array，默认：'auto' &nbsp; 在默认状态下，layer是宽高都自适应的，但当你只想定义宽度时，你可以area: '500px'，高度仍然是自适应的。当你宽高都要定义时，你可以area: ['500px', '300px'] **（6）、offset - 坐标** &nbsp; 类型：String/Array，默认：垂直水平居中 &nbsp; offset默认情况下不用设置。但如果你不想垂直水平居中，你还可以进行以下赋&#20540;： ![](http://img.blog.csdn.net/20161215194647384?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjc2MjYzMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center) **（7）、icon - 图标。信息框和加载层的私有参数** &nbsp; 类型：Number，默认：-1（信息框）/0（加载层） &nbsp; 信息框默认不显示图标。当你想显示图标时，默认皮肤可以传入0-6，如果是加载层，可以传入0-2。 **（8）、btn - 按钮** &nbsp; 类型：String/Array，默认：'确认' &nbsp; 信息框模式时，btn默认是一个确认按钮，其它层类型则默认不显示，加载层和tips层则无效。当您只想自定义一个按钮时，你可以btn: '我知道了'，当你要定义两个按钮时，你可以btn: ['yes', 'no']。当然，你也可以定义更多按钮，比如：btn: ['按钮1', '按钮2', '按钮3', …]，按钮1和按钮2的回调分别是yes和cancel，而从按钮3开始，则回调为btn3: function(){}，以此类推。 **（9）、btnAlign - 按钮排列** &nbsp; 类型：String，默认：r &nbsp; 你可以快捷定义按钮的排列位置，btnAlign的默认&#20540;为r，即右对齐。btnAlign: 'l'，按钮左对齐；btnAlign: 'c'，按钮居中对齐。 **（10）、closeBtn - 关闭按钮** &nbsp; 类型：String/Boolean，默认：1 &nbsp; layer提供了两种风&#26684;的关闭按钮，可通过配置1和2来展示，如果不显示，则closeBtn: 0 **（11）、shade - 遮罩** &nbsp; 类型：String/Array/Boolean，默认：0.3 &nbsp; 即弹层外区域。默认是0.3透明度的黑色背景（'#000'）。如果你想定义别的颜色，可以shade: [0.8, '#393D49']；如果你不想显示遮罩，可以shade: 0 **（12）shadeClose - 是否点击遮罩关闭** &nbsp; 类型：Boolean，默认：false &nbsp; 如果你的shade是存在的，那么你可以设定shadeClose来控制点击弹层外区域关闭。 **（13）、time - 自动关闭所需毫秒** &nbsp; 类型：Number，默认：0 &nbsp; 默认不会自动关闭。当你想自动关闭时，可以time: 5000，即代表5秒后自动关闭，注意单位是毫秒（1秒=1000毫秒） **（14）、id - 用于控制弹层唯一标识** &nbsp; 类型：String，默认：空字符 &nbsp; 设置该&#20540;后，不管是什么类型的层，都只允许同时弹出一个。一般用于页面层和iframe层模式 **（15）anim - 动画** &nbsp; 类型：Number，默认：0 &nbsp; 我们的出场动画全部采用CSS3。这意味着除了ie6-9，其它所有浏览器都是支持的。目前anim可支持的动画类型有0-6 ，（请注意，3.0之前的版本用的 shift 参数） **（16）maxmin - 最大最小化。** &nbsp; 类型：Boolean，默认：false &nbsp; 该参数&#20540;对type:1和type:2有效。默认不显示最大小化按钮。需要显示配置maxmin: true即可 **（17）fixed - 固定** &nbsp; 类型：Boolean，默认：true &nbsp; 即鼠标滚动时，层是否固定在可视区域。如果不想，设置fixed: false即可 **（18）、resize - 是否允许拉伸** &nbsp; 类型：Boolean，默认：true &nbsp; 默认情况下，你可以在弹层右下角拖动来拉伸尺寸。如果对指定的弹层屏蔽该功能，设置 false即可。该参数对loading、tips层无效 **（19）、scrollbar - 是否允许浏览器出现滚动条** &nbsp; 类型：Boolean，默认：true &nbsp; 默认允许浏览器滚动，如果设定scrollbar: false，则屏蔽 **（20）、maxWidth - 最大宽度** &nbsp; 类型：，默认：360 &nbsp; 请注意：只有当area: 'auto'时，maxWidth的设定才有效。 **（21）、zIndex - 层叠顺序** &nbsp; 类型：，默认：19891014（贤心生日 0.0） &nbsp; 一般用于解决和其它组件的层叠冲突。 **（22）、move - 触发拖动的元素** &nbsp; 类型：String/DOM/Boolean，默认：'.layui-layer-title' &nbsp; 默认是触发标题区域拖拽。如果你想单独定义，指向元素的选择器或者DOM即可。如move: '.mine-move'。你还配置设定move: false来禁止拖拽 **（23）、moveOut - 是否允许拖拽到窗口外** &nbsp; 类型：Boolean，默认：false &nbsp; 默认只能在窗口内拖拽，如果你想让拖到窗外，那么设定moveOut: true即可 **（24）、moveEnd - 拖动完毕后的回调方法** &nbsp; 类型：Function，默认：null &nbsp; 默认不会触发moveEnd，如果你需要，设定moveEnd: function(){}即可。 **（25）、tips - tips方向和颜色** &nbsp; 类型：Number/Array，默认：2 &nbsp; tips层的私有参数。支持上右下左四个方向，通过1-4进行方向设定。如tips: 3则表示在元素的下面出现。有时你还可能会定义一些颜色，可以设定tips: [1, '#c00'] **（26）、tipsMore - 是否允许多个tips** &nbsp; 类型：Boolean，默认：false &nbsp; 允许多个意味着不会销毁之前的tips层。通过tipsMore: true开启 **（27）、success - 层弹出后的成功回调方法** &nbsp; 类型：Function，默认：null &nbsp; 当你需要在层创建完毕时即执行一些语句，可以通过该回调。success会携带两个参数，分别是当前层DOM当前层索引。 **（28）、yes - 确定按钮回调方法** &nbsp; 类型：Function，默认：null &nbsp; 该回调携带两个参数，分别为当前层索引、当前层DOM对象。 layer.open({ content: '测试回调', yes: function(index, layero){ //do something layer.close(index); //如果设定了yes回调，需进行手工关闭 } }); **（29）、cancel - 右上角关闭按钮触发的回调** &nbsp; 类型：Function，默认：null &nbsp; 该回调同样只携带当前层索引一个参数，无需进行手工关闭。如果不想关闭，return false即可， //只有当点击confirm框的确定时，该层才会关闭 cancel: function(index){ if(confirm('确定要关闭么')){ layer.close(index) } return false; } **（30）、end - 层销毁后触发的回调** &nbsp; 类型：Function，默认：null &nbsp; 无论是确认还是取消，只要层被销毁了，end都会执行，不携带任何参数。 **（31）、full/min/restore -分别代表最大化、最小化、还原 后触发的回调** &nbsp; 类型：Function，默认：null &nbsp; 携带一个参数，即当前层DOM **2、实例** &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;layer-更懂你的web弹窗解决方案&lt;/title&gt; &lt;script src=&quot;layer/jquery-1.10.2.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;layer/layer.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;layer/skin/default/layer.css&quot; /&gt; &lt;style&gt; div.conten{ width: 100%; border: 2px solid #C9C5C5; margin-bottom: 10px; box-shadow: 5px 5px #CCCCCC; text-align: center; } button.bt{ width: 100px; height: 40px; line-height: 40px; background-color:#2D93CA; border-radius: 10px; color:white; text-align: center; font-weight: bold; font-size: 15px; } .layer_notice{ margin-bottom: 10px; text-align: center; width:200px; color: #999999; margin: 0px auto; } .layer-photos-demo{ text-align: center; width:500px; color: #999999; margin: 0px auto; border: 2px solid #C9C5C5; margin-bottom: 10px; box-shadow: 5px 5px #CCCCCC; } body .demo-class .layui-layer-demo{background:#333;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;conten&quot;&gt; &lt;button onclick=&quot;common(1)&quot; class=&quot;bt&quot;&gt;普通信息框&lt;/button&gt; &lt;button onclick=&quot;common(2)&quot; class=&quot;bt&quot;&gt;图标&lt;/button&gt; &lt;button onclick=&quot;common(3)&quot; class=&quot;bt&quot;&gt;询问框&lt;/button&gt; &lt;button onclick=&quot;common(4)&quot; class=&quot;bt&quot;&gt;提示层&lt;/button&gt; &lt;button onclick=&quot;common(5)&quot; class=&quot;bt&quot;&gt;墨绿深蓝风&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;conten&quot;&gt; &lt;button onclick=&quot;common(6)&quot; class=&quot;bt&quot;&gt;捕获页&lt;/button&gt; &lt;button onclick=&quot;common(7)&quot; class=&quot;bt&quot;&gt;页面层&lt;/button&gt; &lt;button onclick=&quot;common(8)&quot; class=&quot;bt&quot;&gt;自定页&lt;/button&gt; &lt;button onclick=&quot;common(9)&quot; class=&quot;bt&quot; &gt;tips层&lt;/button&gt; &lt;button onclick=&quot;common(10)&quot; class=&quot;bt&quot;&gt;iframe层&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;conten&quot;&gt; &lt;button onclick=&quot;common(11)&quot; class=&quot;bt&quot;&gt;iframe窗&lt;/button&gt; &lt;button onclick=&quot;common(12)&quot; class=&quot;bt&quot;&gt;加载层&lt;/button&gt; &lt;button onclick=&quot;common(13)&quot; class=&quot;bt&quot;&gt;loading层&lt;/button&gt; &lt;button onclick=&quot;common(14)&quot; class=&quot;bt&quot;&gt;小tips&lt;/button&gt; &lt;button onclick=&quot;common(15)&quot; class=&quot;bt&quot;&gt;prompt层&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;conten&quot;&gt; &lt;button onclick=&quot;common(16)&quot; class=&quot;bt&quot;&gt;tap层&lt;/button&gt; &lt;button onclick=&quot;common(17)&quot; class=&quot;bt&quot;&gt;相册层&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot; layer_notice&quot;&gt;傲不可长，欲不可纵，乐不可极，志不可满。&lt;/div&gt; &lt;div id=&quot;layer-photos-demo&quot; class=&quot;layer-photos-demo&quot;&gt; &lt;img layer-pid=&quot;图片id，可以不写&quot; layer-src=&quot;img/1.jpg&quot; src=&quot;img/11.jpg&quot; alt=&quot;图片名&quot;&gt; &lt;img layer-pid=&quot;图片id，可以不写&quot; layer-src=&quot;img/2.jpg&quot; src=&quot;img/22.jpg&quot; alt=&quot;图片名&quot;&gt; &lt;img layer-pid=&quot;图片id，可以不写&quot; layer-src=&quot;img/4.jpg&quot; src=&quot;img/44.jpg&quot; alt=&quot;图片名&quot;&gt; &lt;img layer-pid=&quot;图片id，可以不写&quot; layer-src=&quot;img/5.jpg&quot; src=&quot;img/55.jpg&quot; alt=&quot;图片名&quot;&gt; &lt;img layer-pid=&quot;图片id，可以不写&quot; layer-src=&quot;img/7.jpg&quot; src=&quot;img/77.jpg&quot; alt=&quot;图片名&quot;&gt; &lt;/div&gt; &lt;script&gt; function common(n){ if(n==1){ //layer.alert(content, options, yes) - 普通信息框 layer.alert('有了回调', {title:'提示'},function(index){ layer.alert('加了个图标', {icon: 1},function(index){ layer.alert('只想简单的提示',function(index){ layer.close(index);//没有close就需要手动关闭 }); }); }); }else if(n==2){ //图标 layer.alert('图标0', {icon: 0},function(index){ layer.alert('图标'+index, {icon: 1},function(index){ layer.alert('图标'+index, {icon: 2},function(index){ layer.alert('图标'+index, {icon: 3},function(index){ layer.alert('图标'+index, {icon: 4},function(index){ layer.alert('图标'+index, {icon: 5},function(index){ layer.alert('图标'+index, {icon: 6},function(index){ layer.close(index); }) }) }) }) }) }) }) }else if(n==3){ //layer.confirm(content, options, yes, cancel) - 询问框 layer.confirm('您是如何看待前端开发？', { btn: ['重要','奇葩'], //按钮 icon: 3, title:'提示' }, function(){ layer.msg('的确很重要', {icon: 1}); }, function(){ layer.msg('也可以这样', { time: 20000, //20s后自动关闭 btn: ['明白了', '知道了'] }); }); }else if(n==4){ //layer.msg(content, options, end) - 提示框，3秒后自动消失 layer.msg('玩命提示中',{ icon: 1, time: 2000 //2秒关闭（如果不配置，默认是3秒） }, function(){ layer.msg('呵呵'); }); }else if(n==5){ //墨绿深蓝风 layer.alert('墨绿风格，点击确认看深蓝', { skin: 'layui-layer-molv', //样式类名 closeBtn: 0//layer提供了两种风格的关闭按钮 }, function(){ layer.alert('深蓝style', { skin: 'layui-layer-lan', closeBtn: 0,//layer提供了两种风格的关闭按钮 anim: 4 //动画类型 }); }); }else if(n==6){ //捕获页 layer.open({ type: 1, shade: false, area: ['420px', '240px'], //宽高 title: false, //不显示标题 content: $('.layer_notice'), //捕获的元素 cancel: function(){ layer.msg('捕获就是从页面已经存在的元素上，包裹layer的结构', { time: 5000, icon:6 }); } }); }else if(n==7){ //页面层 layer.open({ type: 1, skin: 'layui-layer-rim', //加上边框 area: ['420px', '240px'], //宽高 content: 'html内容' }); }else if(n==8){ //自定页 layer.open({ type: 1, skin: 'layui-layer-demo', //样式类名 closeBtn: 0, //不显示关闭按钮 anim: 2,//anim可支持的动画类型有0-6 shadeClose: true, //开启遮罩关闭 content: '内容' }); }else if(n==9){ //tips层 layer.tips('Hi，我是tips', '.layer_notice',{tips:2}); }else if(n==10){ //iframe层 layer.open({ type: 2, title: 'layer mobile页', shadeClose: true,//是否点击遮罩关闭 shade:[0.8,'#393D49'],//遮罩 area: ['380px', '90%'], content: 'http://blog.csdn.net/qq_27626333/article/details/53674829' //iframe的url }); }else if(n==11){ //iframe窗 layer.open({ type: 2, title: false, closeBtn: 0, //不显示关闭按钮 shade: [0],//不显示遮罩 area: ['340px', '215px'], offset: 'rb', //右下角弹出 time: 2000, //2秒后自动关闭 anim: 2, content: ['http://blog.csdn.net/qq_27626333/article/details/53674829', 'no'], //iframe的url，no代表不显示滚动条 end: function(){ //此处用于演示 layer.open({ type: 2, title: '很多时候，我们想最大化看，比如像这个页面。', shadeClose: true, shade: false, maxmin: true, //开启最大化最小化按钮 area: ['893px', '600px'], content: 'http://blog.csdn.net/qq_27626333/article/details/53674829' }); } }); }else if(n==12){ //layer.load(icon, options) - 加载层 var index = layer.load(2, {time: 10*1000}); //又换了种风格，并且设定最长等待10秒 //关闭 //layer.close(index); }else if(n==13){ //loading层 var index = layer.load(1, { shade: [0.1,'#fff'],//0.1透明度的白色背景 time:1000 }); }else if(n==14){ //小tips layer.tips('我是另外一个tips，只不过我长得跟之前那位稍有些不一样。', '.layer_notice', { tips: [1, '#3595CC'], time: 4000 }); }else if(n==15){ //layer.prompt(options, yes) - 输入层 //formType: 1, //输入框类型，支持0（文本）默认1（密码）2（多行文本） //value: '', //初始时的值，默认空字符 //maxlength: 140, //可输入文本的最大长度，默认500 //yes携带value表单值、index索引、elem表单元素 layer.prompt({title: '输入任何口令，并确认', formType: 1}, function(pass, index){ layer.close(index); layer.prompt({title: '随便写点啥，并确认', formType: 2}, function(text, index){ layer.close(index); layer.msg('演示完毕！您的口令：'+ pass +'您最后写下了：'+text); }); }); }else if(n==16){ //layer.tab(options) - tab层 layer.tab({ area: ['600px', '300px'], tab: [{ title: 'TAB1', content: '内容1' }, { title: 'TAB2', content: '内容2' }, { title: 'TAB3', content: '内容3' }] }); }else if(n==17){ //相册层 layer.photos({ photos: '#layer-photos-demo', anim: 5 //0-6的选择，指定弹出图片动画类型，默认随机（请注意，3.0之前的版本用shift参数） }); } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JQuery</tag>
      </tags>
  </entry>
</search>